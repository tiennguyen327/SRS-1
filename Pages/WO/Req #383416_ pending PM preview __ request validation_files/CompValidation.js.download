/**
 *  Javascript Component creation library.
 */
var DECODE_DELIMITER = ".";
var MULTIAUTO_DELIMITER = "#@#";
var MULTICHOOSER_DELIMITER = "\",\"";
var COMMA_SPACE = ", ";
var COMMA = ",";
var SEMICOLON_SPACE = "; ";
var CODE_SIZE_INDEX = 0;
var MEANING_SIZE_INDEX = 1;
var DEFAULT_DATE = "1970-01-01";
var BLANK_PAGE    = "/itg/web/knta/global/Dummy.jsp";
var encodeServletParams = false;
var autoCompPopupServlet = "/itg/web/knta/global/AutoCompPopup.jsp?";
var fileFolderChooserPopupServlet = "/itg/web/knta/global/FileDirChooserPopup.jsp?";
var autoCompPreVerifyServlet = "/itg/web/knta/global/AutoCompPreVerify.jsp?";
var autoCompImgSrc = "/itg/web/knta/global/images/Autocomp.gif";
var autoCompDisabledImgSrc = "/itg/web/knta/global/images/Autocomp_off.gif";
var userAutoCompImgSrc = "/itg/web/knta/global/images/UserAutocomp.gif";
var userAutoCompDisabledImgSrc = "/itg/web/knta/global/images/UserAutocomp_off.gif";
var rscFindImgSrc = "/itg/web/knta/global/images/ResourceFinder.gif";
var rscFindDisabledImgSrc = "/itg/web/knta/global/images/ResourceFinder_off.gif";
var dateTimeImgSrc = "/itg/web/knta/global/images/date_time.gif";
var dateTimeDisabledImgSrc = "/itg/web/knta/global/images/date_time_off.gif";
var passwordPopupServletPath = "/itg/web/knta/global/Password.jsp?";
var autoCompleteWidth = 700;
var autoCompleteHeight = 620;
var chooserPopupWidth = 700;
var chooserPopupHeight = 620;
var ACPopupNamePostFix = "ACPopup";
var ChooserPopupNamePostFix = "ChooserPopup";
var autoPopulateController = "/itg/web/knta/global/autoPopulate.jsp";
var datePopupServlet = "/itg/web/knta/global/DateTimeChooser.jsp?";
var dateValidateJSP = "/itg/web/knta/global/dateValidate.jsp?";
var datePopupWidth = 220;
var datePopupHeight = 340;
var datePopupDateOnlyHeight = 235;
var datePopupTimeOnlyHeight = 115;
var DFPopupNamePostFix = "DFPopup";
var PresentationKeyParam = "PK";
var ON_CREATION = 1;
var ON_FLD_CHNGE = 2;
var ON_FLD_CHNGE_AND_STOP_RULES = 3;
var PARENT_ENTITY_TYPE_ID = "PARENT_ENTITY_TYPE_ID";
var VALIDATION_ENTITY_ID = 13;
var REQUEST_TYPE_ENTITY_ID = 19;
var REPORT_TYPE_ENTITY_ID = 17;
var ENTITY_TYPE_ID = "ENTITY_TYPE_ID";
var PRIMARY_KEY    = "PRIMARY_KEY";
var RULES_PARAM    = "RULES";
var RULE_DELIMITER = "@^@ "; // need the space after it in case the next value is empty
var RULE_TOKEN_DELIMITER = "#";
var HOVER_LOCATOR_SUFFIX = "HVR_LOCATOR";
var AC_TEXTFIELD_ID_SUFFIX = "AC_TF";
// rule types - these must match those defined in com.kintana.core.util.RuleFieldUtils
var SIMPLE = 1;
var ADVANCED = 2;
var DISPLAY_ONLY = 3;
var DEPENDS_ON_PARAM = 4;
var REQUIRED = 5;
var CLEAR = 6;
// prefix for the <span> tag to set the "*"
var REQ_PREFIX = "REQ-";
var REQ_ASTERISK = "<span class='field-prompt-asterisk'>*</span>";
var URL_LIMIT = 2000;

var undef;
// this variable will be redefined by Kintana pages
var base_url;
var showAlert = true;
var resolvedPageTokens="";
var passwordMask = "*****";
var passwordBlank = "(blank)";
var passwordWidth = 600;
var passwordHeight = 300;
var REQ_TABLE_TOKEN_PREFIX = "REQD.T.";
var TABLECOMPFORM_PREFIX = "TEF";
// these variables stored the current component that has focus
// common about all these: need validation afterwards
var focussedAutoComp;
var focussedDate;
var focussedText;

//This variable is used to skip checking for null when saving Request draft.
var checkRequired = true;
//This variable is used in the TableEntryForm to determine whether hashing
//page tokens is needed or not.
var hashParentChildPageTokens = false;
/**
 *  returns a unique key.
 */

var globalStyleSheet = "";

// To keep track if a Auto-complete is verifying.
var isAutoCompVerifying = false;
// Reference the source window.
var srcparent;
if(window.opener != undef) {
    srcparent = window.opener;
} else {
    srcparent = window.parent;
}

function getUniqueKey(){
    var myDate = new Date();
    return myDate.getTime();
}
/**
 *  Does nothing. Used as a placeholder for href tags on components such as the autocomplete
 *  the date field, and the password field.
 */
function noop() {
}
/**
 *  gets the hostpath variable of the global template.
 */
function getHostPath()
{
  return "";
}
/**
 *  modelled after Java.lang.String.trim()
 *  Removes unwanted blank chars from the head
 *  and tail of the string
 */
function trimString(myStr) {
    var undefined;
    if (myStr == undefined)
       return undefined;
    var start = 0;
    var count = myStr.length;
    var end = count;
    while((start < count) && (myStr.charAt(start) <= ' ')) {
        start++;
    }
    while((start < end) && (myStr.charAt(end-1) <= ' ')) {
        end--;
    }
    return ((start > 0) || (end < count)) ? myStr.substring(start, end) : myStr;
}

function textarea_onChange(maxSize, name, element) {
    trimAlert(maxSize, name, element );

    var jsObj = findJSOForElement(element);
    if( jsObj && jsObj.RuleArray && jsObj.RuleArray.length > 0 ) {
	    RuleUtil.isPendingFlag = true;
        RuleUtil.evaluateRules(jsObj.RuleArray, jsObj.getValue(), jsObj.isCodeString());
    }
}

function textarea_setValue(codestring) {
    this.setTextValue(codestring);
    trimAlert(this.maxSize, this.clLabel, this.element );
}

/**
 * Trims the number of characters contained within a text area down to maxSize.
 * Also alerts the user that it has done so.
 */
function trimAlert(maxSize, name, element) {
    if ((maxSize > 0) && (element.value.length > maxSize)) {
        element.value = element.value.substring(0, maxSize);
        alert(formatMessage(trimMsg, name));
    }
}

function yes_codestring() {
    return "Y";
}

function no_codestring() {
    return "N";
}

/**
 *  returns a codestring
 */
function encode(code, meaning){
	//debugger;
        if( code == null ) {
            code = "";
        }
        if( meaning == null ) {
            meaning = "";
        }
        var encode = "";

        // when code = "", we should create an array of size 1 so that
        // it still works in the case when meaning is not empty.
        var codes = [];
        if (code == "") {
            codes[0] = "";
        } else {
            codes = code.split(MULTIAUTO_DELIMITER);
        }
        // similar for meaning
        var meanings = [];
        if (meaning == "") {
            meanings[0] = "";
        } else {
            // Request #153089 - multiple Program Managers for Program cause
            //                   JavaScript error in Autocomplete fields
            if (meaning.indexOf(MULTIAUTO_DELIMITER)>-1) {
                meanings = meaning.split(MULTIAUTO_DELIMITER);
            } else {
            	meanings = meaning.split(SEMICOLON_SPACE);
			        // Request #189949 - can't have more meanings then codes
           	        if ((codes.length == 1) && (meanings.length > 1)) {
        				meanings[0] = meaning;
        			}
            }
        }

        for(var i=0; i<codes.length; i++) {
            encode += codes[i].length;
            encode += '.';
            encode += meanings[i].length;
            encode += '.';
            encode += codes[i];
            encode += '.';
            encode += meanings[i];

            if(i+1 != codes.length) {
                encode += MULTIAUTO_DELIMITER;
            }
        }
        return encode;
}



/**
 *  returns the meaning if returnMeaning is set to true.
 *  returns the code if returnMeaning is set to false.
 *  Now supports Multi-value autocomplete
 */
function decode(code, returnMeaning){
    if (code == null || code == ""){
        return "";
    }
    // separate the codeString into segments
    var segments = code.split(MULTIAUTO_DELIMITER);
    var returnValue;
    if (returnMeaning) { // return meaning
        // call decodeCodeString to do the single CodeString decode
        returnValue = decodeCodeString(segments[0], true);
        for (var i=1; i < segments.length; i++) {
            returnValue  = returnValue + SEMICOLON_SPACE + decode(segments[i], true);
        }
    } else { // return code
        returnValue = decodeCodeString(segments[0], false);
        for (var i=1; i < segments.length; i++) {
            returnValue  = returnValue + MULTIAUTO_DELIMITER + decode(segments[i], false);
        }
    }
    return returnValue;
}

/**
 *  returns the meaning if returnMeaning is set to true.
 *  returns the code if returnMeaning is set to false.
 *  Now supports Multi-value autocomplete
 */
function FDdecode(code, returnMeaning, IsMulti){

    if (code == null || code == ""){
        return "";
    }
    // separate the codeString into segments
    var segments = code.split(MULTIAUTO_DELIMITER);
    var returnValue;

           // call decodeCodeString to do the single CodeString decode
        returnValue = decodeCodeString(segments[0], returnMeaning);

	if (IsMulti){
	  //if (returnValue != "")
	              returnValue = "\"" + returnValue +   "\"";
	}
        for (var i=1; i < segments.length; i++) {
	    if(IsMulti){
                  returnValue  = returnValue + COMMA + "\"" +decode(segments[i], returnMeaning)+"\"";
	    } else{
	          returnValue  = returnValue + COMMA_SPACE + decode(segments[i], returnMeaning);
	    }
        }

    return returnValue;
}

/**
 *  Encode the meaning and return the code for File/Dir chooser component
 */
function FDMultiEncode(meaning){

    if (meaning == null || meaning == ""){
        return "";
    }
    // separate the codeString into segments

    var segments = null;
    var temp = meaning.substring(1, meaning.length - 1);
    segments = temp.split(MULTICHOOSER_DELIMITER);
    var encode = "";

    for(var i=0; i<segments.length; i++) {
    	if(segments[i] != null && segments[i] != "" && segments[i] != "\"\"") {
	        encode += segments[i].length;
	        encode += '.';
	        encode += segments[i].length;
	        encode += '.';
	        encode += segments[i];
	        encode += '.';
	        encode += segments[i];
        } else {
        	encode += "0.0..";
        }

        if(i+1 != segments.length) {
            encode += MULTIAUTO_DELIMITER;
        }
    }
    return encode;
}


/**
 *  Yanked from EXStringUtils, and therefore LiteUtils
 *  decode function, we can't just split the string up since
 *  sometimes the code or the meaning contains the dot "." delimiter which
 *  screws up our decoding mechanism.
 */
function decodeCodeString(code, returnMeaning) {
    var fromHTML = deEscapeFromHTML(code);
    var decodedString = fromHTML.split(DECODE_DELIMITER);
    if(decodedString.length < 4){
        return code;
    }
    var codeSize = decodedString[CODE_SIZE_INDEX];
    var meaningSize = decodedString[MEANING_SIZE_INDEX];
    var thirdDelimitLoc = parseInt(codeSize)+
                          DECODE_DELIMITER.toString().length * 2 +
                          codeSize.toString().length +
                          meaningSize.toString().length;
    var totalLength = parseInt(codeSize)+
                      parseInt(meaningSize)+
                      DECODE_DELIMITER.toString().length * 3 +
                      codeSize.toString().length +
                      meaningSize.toString().length;
    if(totalLength != fromHTML.toString().length ||
       fromHTML.substr(thirdDelimitLoc, DECODE_DELIMITER.toString().length) !=
       DECODE_DELIMITER){
        return code;
    }
    var codeStartLoc = codeSize.toString().length + meaningSize.toString().length + DECODE_DELIMITER.toString().length * 2;
    if(returnMeaning == true){
        startingIndex = parseInt(codeStartLoc)+parseInt(codeSize) + DECODE_DELIMITER.toString().length;
        return fromHTML.substr(startingIndex);
    } else{
        startingIndex = parseInt(codeStartLoc);
        return fromHTML.substr(startingIndex, parseInt(codeSize));
    }
}

/**
 * Taken from ExpressUtils.  We need to do this on the Javascript side because
 * javascript doesn't understand the HTML escaped characters (argh).
 */
function deEscapeFromHTML(value) {
    var undef;
    if(value == undef || value == "") {
        return "";
    }
    value = value.replace(/&lt;/gi, "<");
    value = value.replace(/&gt;/gi, ">");
    value = value.replace(/&quot;/gi, "\"");
    // de-escape both 039 and 39 for right now
    // until I can make sure we only use 39
    value = value.replace(/&#039;/gi, "'");
    value = value.replace(/&#39;/gi, "'");
    value = value.replace(/&amp;/gi, "&");

    return value;
}

/**
 * Taken from WebUtils, so that users' data is safe to display in HTML
 * from JavaScript.
 */
function escapeForHTML(value) {
    var undef;
    if(value == undef || value == "") {
        return "";
    }

    // It's important that the ampersand is substituted first!
    value = value.replace(/&/gi, "&amp;");
    value = value.replace(/</gi, "&lt;");
    value = value.replace(/>/gi, "&gt;");
    value = value.replace(/\"/gi, "&quot;");
    value = value.replace(/\'/gi, "&#39;");

    return value;
}

/**
 * In IE 5.5 and NS 6.0 onward, this function is replaceable
 * with encodeURI.  For now, this function convert multi-bytes
 * characters into %ab%cd string.
 * To debug, see: http://www.ietf.org/rfc/rfc2279.txt
 */
function escapeForURI(value) {
  // first we replace double-quotes with HTML entity
  value = value.replace(/\"/gi, "&quot;");
  // then we escape, this would give us %uxxxx for multi-bytes
  value = escape(value);
  var finalStr = "";
  var tmpStr;
  var regExp;
  var j=0;
  if(serverEncoding.toUpperCase() == "UTF-8") {
    regExp = /%[A-Z0-9][A-Z0-9]/g;
    j=0;
    i = value.search(regExp);
    finalStr = "";
    while(i!=-1){
      tmpStr = value.substr(i,3);
      tmpStr = unescape(tmpStr);
      tmpStr = tmpStr.charCodeAt(0);
      tmpStr = convertToUTF8(tmpStr);
      j=tmpStr.length-2;
      while(j>=0){
        tmpStr = tmpStr.substr(0,j).concat("%",tmpStr.substr(j));
        j = j-2;
      }
      finalStr = finalStr.concat(value.substr(0,i));
      finalStr = finalStr.concat(tmpStr);
      value = value.slice(i+3);
      i = value.search(regExp);
    }
    value = finalStr + value;
  }
  j=0;
  regExp = /%u[\d\w][\d\w][\d\w][\d\w]/g;
  var i = value.search(regExp);
  while(i!=-1){
    tmpStr = value.substr(i,6);
    tmpStr = unescape(tmpStr);
		tmpStr = tmpStr.charCodeAt(0);
    tmpStr = convertToUTF8(tmpStr);
    j=tmpStr.length-2;
    while(j>=0){
      tmpStr = tmpStr.substr(0,j).concat("%",tmpStr.substr(j));
      j = j-2;
    }
    finalStr = value.substr(0,i);
    finalStr = finalStr.concat(tmpStr,value.substr(i+6));
    value = finalStr;
    i = value.search(regExp);
  }
  return value;
}


/**
 * convert given character code into UTF-8, in form
 * of 2- or 4-digit hex.
 */
function convertToUTF8(value){
  var retVal="";
  var remainder;
  var highFill = 0x80;
  var fill = 0x80;
  if(value<=0x7f){
    retVal=convertToHex(value);
  }else{
    while(true){
      if(value>highFill){
        remainder=value%0x40;
        remainder=fill+remainder;
        retVal=convertToHex(remainder)+retVal;
        value=value>>6;
        highFill=highFill|(highFill>>1);
      }else{
        retVal=convertToHex(highFill+value)+retVal;
        break;
      }
    }
  }
  if(retVal.length%2 == 1) retVal = "0".concat(retVal);
  return retVal;
}

function convertToHex(value){
  var retVal="";
	var remainder;
	while(value>0){
		remainder=value%16;
		if(remainder>9){
		  switch(remainder){
        case 10: remainder="A";break;
        case 11: remainder="B";break;
        case 12: remainder="C";break;
        case 13: remainder="D";break;
        case 14: remainder="E";break;
        case 15: remainder="F";break;
		  }
    }else{
      remainder=String(remainder);
    }
    retVal=remainder.concat(retVal);
    value = value >> 4;
  }
  return retVal;
}

/**
 *  Standard prototype function getLabel is used by
 *  almost all Component objects.
 */
function getLabel(){
    return this.clLabel;
}

function requiredAlert(name) {
if (showAlert) {
  alert(formatMessage(reqMessage,deEscapeFromHTML(name)));
}
}
/**
 * Bug: 83256 Making the message more user friendly.
 */
function requiredAlertAutoComp(name) {
if (showAlert) {
  alert(formatMessage(reqMessage, deEscapeFromHTML(name))+' '+noneSelected);
}
}

/*
 * Standard getTokenValue function shared by several form elements.
 */
function std_getTokenValue(isVisible) {
    if(this.validate(true)){
        return decode(this.element.value, isVisible);
    }else{
        return "";
    }
}


/**
 * Register Rule as a listener to the object.
 */
function rules_addListener(rule) {
    this.RuleArray[rule.sequence] = rule;
}

/**
 * Returns true if valArray matches the value(s) of the field.
 * Takes into account multi-select fields.
 */
function rules_chkValue(valArray, isCodeString) {
    curValArray = this.currentCSValue.split(MULTIAUTO_DELIMITER);

    if(curValArray.length != valArray.length) {
        return false; // There isn't a chance the values match
    }

    for (var i = 0; i < valArray.length; i++) {
        var found = false;
        for (var j = 0; j < curValArray.length; j++) {
            if(!isCodeString) {
                value = decode(curValArray[j], true);
            } else {
                value = curValArray[j];
            }
            if(valArray[i] == value) {
                curValArray.splice(j, 1); // Delete the found element
                found = true;
               break;
            }
        }
        if(!found) {
            return false;
        }
    }

    return true;
}

/**
 *  BEGIN DROPDOWNLIST OBJECT
 */
/**
 *  Validation method for the drop down list object.
 */
function _validateDropDownList(forceCheck) {
    //error if required and selection matches empty value
    if(checkRequired && ( this.required==true || (forceCheck != null && forceCheck)) &&
      (( this.options.length == 0 || this.options[this.element.selectedIndex].value== this.emptyString) || (this.options[this.element.selectedIndex].value== "0.0.."))
    ) {
        requiredAlert(this.clLabel);
        return false;
    }
    if(this.validationCall != "") {
        val = eval(this.validationCall);
        return val;
    }
    return true;

}

/**
 *  retrieves the token value of a drop down list object.  If isVisible is true it
 *  gets the visible token value.
 */
function ddl_getTokenValue(isVisible){
    if(this.validate(true)){
        visibleValue = decode(this.options[this.element.selectedIndex].value, isVisible);
        codeValue = decode(this.options[this.element.selectedIndex].value, false);
        if(visibleValue == null){
            return "";
        }else{
            if (codeValue == BLANK_VALUE_CODE_STRING) {
              return "";
            }
            return visibleValue;
        }
    }else{
        return "";
    }
}

/**
 * Set the value of the drop down list.  Note the value is the value="..." parameter from the
 * options tag.  It is not the visible text that the user sees.
 */
function ddl_setValue(value, noCascade, ruleSeq, ruleName) {
    options = this.options;
    l = options.length;
    var found = false;
    for ( i = 0; i < l; i++ ) {
       if ( decode(options[i].value, false) == decode(value, false) ||
            decode(options[i].value, true) == decode(value, true)) {
           options[i].selected = true;
           found = true;
       }
       else {
           options[i].selected = false;
       }
    }
    this.currentCSValue = this.options[this.element.selectedIndex].value;

    if(!found && showAlert) {
        alert(formatMessage(invalidDropDownVal, this.clLabel, decode(value, true), ruleSeq, ruleName));
    }
}

function ddl_onValueChange() {
    suspendOnclickEvents();
    RuleUtil.isPendingFlag = true;
    var jso = findJSOForElement(this);
    if(jso != null && jso.onValueChange != null && jso.onValueChange != "") {
        eval(jso.onValueChange);
    }
}

function ddl_getValue() {
    options = this.options;
    index = this.element.selectedIndex;

    return options[index].value;
}

function ddl_onBlur() {
    var obj = findJSOForElement(this);

    if(obj.RuleArray.length > 0 &&
       obj.currentCSValue != this.options[this.selectedIndex].value) {
       RuleUtil.isPendingFlag = true;
       obj.currentCSValue = this.options[this.selectedIndex].value;
       RuleUtil.evaluateRules(obj.RuleArray, obj.getValue(), obj.isCodeString());
    }else{
        RuleUtil.isPendingFlag = false;
        resumeOnclickEvents();
    }
}

function rules_isNotEmpty() {
    return (this.emptyString != this.currentCSValue);
}

/*
 * Every Kintana JSO (DropDownList, HiddenField, etc.) is associated
 * with an HTML Form element. Initially, we added a back reference
 * from the element back to the JSO using a property, usually "obj".
 * However, IE6 has problems with circular references, where the JSO
 * refers to the element, and the element back to the JSO. This causes
 * a HUGE memory leak. (Netscape 7 doesn't have this problem.)
 *
 * To avoid memory leakage in IE6, we cannot have a property of
 * an HTML Input element reference back the JSO directly. The good
 * news is that we don't even have to. We know that the JSO array
 * variable has the same name as the form, and that it is a global
 * object (part of the window object). We also know that the
 * JSO object in the array has the same name as the HTML Input element.
 * Therefore, we can compute the JSO object from an element using
 * the following code:
 *
 *     eval("window." + element.form.name + "." + element.name);
 *
 * To simplify, here's a function that returns the JSO Object for
 * a given element (or null, if no JSO object exists):
 *
 *     function findJSOForElement(element) {
 *         return eval("window." + element.form.name + "." + element.name);
 *     }
 *
 *
 */

/**
 * Passing in an HTML Input element, returns the associated JSO (such
 * as the DropDownList object).
 */
function findJSOForElement(element) {

    /*
     * The JSO array may not be in the window object, and can be
     * in window.opener or window.parent (for dialogs). Could not
     * figure out how to determine which window that is from the
     * element object itself, so here we try all three of them.
     * Kind of a hack, but it works.
     *
     * For IE6, we can determine the window of an element using
     * the expression "element.form.ownerDocument.parentWindow".
     * Unfortunately, NS doesn't support "parentWindow", and I
     * cannot figure out a way to get the window of a document
     * object. Therefore, this hack will stay until a clean way
     * to determine the containing window of an input element
     * exists.
     */

    var obj = findJSOForElementInWindow(element, window);

    if (obj == null) {
        obj = findJSOForElementInWindow(element, window.opener);
    }

    if (obj == null) {
        obj = findJSOForElementInWindow(element, window.parent);
    }
    return obj;
}

/**
 * helper function
 */
function findJSOForElementInWindow(element, win) {

    if (element && win) {

        var elementName = element.name;

        if (elementName == null && element[0]) {
            // handle the case where element is a collection of
            // radio buttons, in which case we pick the first one
            // to get the element name
            element = element[0];
            elementName = element.name;
        }

        if (elementName) {
            var form = element.form;

            if (form) {
                var formName = form.name;

                if (formName) {
                    var objArray = win[formName];

                    if (objArray) {
                        var obj = objArray[elementName];
                        if (obj && (obj.element == element
                                    || obj.first == element
                                    || obj.second == element
                                    || obj.valueElement == element)) {
                            /* For all objects, except for YesNoRadioButton, we look at the property "element".
                             * For YesNoRadioButton, we have to look at both "first" and "second". For AutoComplete
                             * we also have to consider valueElement.
                             */
                            return obj;
                        }
                    }
                }
            }
        }
    }
    return null;
}


function findJSOForElementId(elementId) {
    var element = document.getElementById(elementId);
    if (element) {
        return findJSOForElement(element);
    }
    else {
        return null;
    }
}

/**
 * find JSO by using the name of the form and the name of the
 * element, looking in window, window.opener, and window.parent.
 */
function findJSOByName(formName, elementName) {
    var obj = findJSOByNameHelper(formName, elementName, window);
    if (obj == null) {
        obj = findJSOByNameHelper(formName, elementName, window.opener);
    }
    if (obj == null) {
        obj = findJSOByNameHelper(formName, elementName, window.parent);
    }

    return obj;
}

function findJSOByNameHelper(formName, elementName, win) {
    if (win == null) {
        return null;
    }

    var array = win[formName];
    if (array) {
        return array[elementName];
    }
    else {
        return null;
    }
}

function DropDownList_setEnabled(flag) {
    if(flag) {
        this.isEnabled = true;
        // set the field's disabled property to be false in IE & Netscape7
        this.element.disabled = false;
    } else {
        this.isEnabled = false;
        this.element.disabled = true;
    }
 }

/**
 *  DropDownList javascript object definition.
 */
function DropDownList(label, element, required, emptyString, tokenName,  visibleTokenName, form, onValueChange, validationCall) {
    this.clLabel = label;
    this.name = element.name;
    this.options = element.options;
    this.element = element;
    this.required = required;
    this.emptyString = emptyString;
    if(this.element.options && this.element.options != null && this.element.options.length>0) {
        this.currentCSValue = this.element.options[this.element.selectedIndex].value;
    }
    else {
        this.currentCSValue = emptyString;
    }

    this.element.onchange = ddl_onValueChange;
    if(tokenName != ""){
        new Token(tokenName, this, false, form);
    }
    if(visibleTokenName != ""){
        new Token(visibleTokenName, this, true, form);
    }
    this.onValueChange = onValueChange;
    this.validationCall = validationCall;
    this.RuleArray = new Array();
    this.element.onblur = ddl_onBlur;
    this.isEnabled = true;
    this.defaultClass = this.element.className;
    this.disabledClass = "textareadisabled";
}

new DropDownList("", "", false, "", "", "", "", "", "");
DropDownList.prototype.validate = _validateDropDownList;
DropDownList.prototype.getTokenValue = ddl_getTokenValue;
DropDownList.prototype.getLabel = getLabel;
DropDownList.prototype.setValue = ddl_setValue;
DropDownList.prototype.getValue = ddl_getValue;
DropDownList.prototype.getValueForRule = ddl_getValue;
DropDownList.prototype.isCodeString = yes_codestring;
DropDownList.prototype.setRequired = generic_setRequired;
DropDownList.prototype.onValueChange = ddl_onValueChange;
DropDownList.prototype.addListener = rules_addListener;
DropDownList.prototype.isNotEmpty = rules_isNotEmpty;
DropDownList.prototype.chkValue = rules_chkValue;
DropDownList.prototype.setEnabled = DropDownList_setEnabled;

/**
 *  END DROPDOWNLIST OBJECT
 */

/**
 *  BEGIN TEXTFIELD OBJECT
 */
/**
 * Returns a number by replacing the userDecimalSep char with a (.) and
 * removing the userDigitGroupSep chars
 */
function getNumberString(numString, label, numberFormattable, useServerRegionalSetting) {
    if( useServerRegionalSetting ) {
        return getProperNumberString(numString, label, numberFormattable, serverDecimalSep, serverDigitGroupSep);
    } else {
        return getProperNumberString(numString, label, numberFormattable, userDecimalSep, userDigitGroupSep);
    }
}

function getProperNumberString(numString, label, numberFormattable, decimalSep, digitGroupSep) {
    if(!numString || numString.length == 0)
        return "";

    if(numString.indexOf(digitGroupSep) != -1 && !numberFormattable) {
        return NUM_NO_GROUP_SEP;
    }

    if(numString.indexOf(digitGroupSep) != -1 &&
       numString.indexOf(decimalSep) != -1 &&
       (numString.indexOf(digitGroupSep) > numString.indexOf(decimalSep))) {
        return NUM_FORMAT_CHARS_INTERCHANGED;
    }
    var num = "";
    var nonFormatChars = '';

    //remove the digit group separators if they are present
    for( var i = 0; i < numString.length; i++) {
       //show error if the entered contains characters other than
       //digits, the user's decimal or digit group separator characters
       if(isNaN(numString.charAt(i))&& (numString.charAt(i) != digitGroupSep &&
                 numString.charAt(i) != decimalSep)&& numString.charAt(i) != '-') {
           nonFormatChars += numString.charAt(i)+',';
       }
       if(numString.charAt(i) != digitGroupSep) {
           num = num + numString.charAt(i);
       }
    }
    if(nonFormatChars != ''){
        if(nonFormatChars.charAt(nonFormatChars.length-1) == ','){
            nonFormatChars = nonFormatChars.substring(0, nonFormatChars.length-1);
        }
        return NUM_NON_FORMAT_CHARS;
    }

    //replace the decimal separator with '.'
    var i = num.indexOf(decimalSep);
    if( i > -1 ) {
        var intPart = num.substring(0, i);
        var decPart = num.substring(i+1, num.length);
        num = intPart + "." + decPart;
    }
    return num;
}

/**
 * format a number into a currency format with server locale
 */
function formatNumberToCurrency(number)
{
    var numString = formatNumber(number, true, 2, true, true);
    numString = serverCurrencyPrefix + numString + serverCurrencySuffix;
    return numString;
}

/**
 * format a number into the a format. Fully formaated if numberFormattable
 * is true. Else only the decimal char is replaced with the users decimal char
 */
function formatNumber(number, numberFormattable, decimalDigits, enforceDecimal, useServerRegionalSettings) {
    if( useServerRegionalSettings ) {
        return formatProperNumber(number, numberFormattable, decimalDigits, enforceDecimal, serverDecimalSep, serverDigitGroupSep, serverDigitsInGroup);
    } else {
        return formatProperNumber(number, numberFormattable, decimalDigits, enforceDecimal, userDecimalSep, userDigitGroupSep, userDigitsInGroup);
    }
}

function formatProperNumber(number, numberFormattable, decimalDigits, enforceDecimal, decimalSep, digitGroupSep, digitsInGroup) {
     var num = number.toString();
     if(!num || num.length == 0) {
         return "";
     }
     var index = num.indexOf(".");
     if(!numberFormattable) {
         if(index != -1){
             num = num.substring(0, index)+decimalSep+num.substring(index+1);
             return num;
         }else {
             return num;
         }
     } else {
         var decimalString = 0;
         var intString = 0;
         if(index != -1){
             decimalString = num.substring(index+1);
             intString = num.substring(0, index);
             if(enforceDecimal && decimalDigits) {
                 while( decimalString.length < decimalDigits ) {
                     decimalString = decimalString + "0";
                 }
             }
             if(intString.length != "" || intString.length != 0 ){
                 return formatInt(intString, digitGroupSep, digitsInGroup)+decimalSep+decimalString;
             }
             else {
                return 0+decimalSep+decimalString;
             }
         }else {
             if(num.length != "" || num.length != 0 ){
                 if( decimalDigits > 0 ) {
                     decimalString = "0";
                 }
                 if(enforceDecimal && decimalDigits) {
                     while( decimalString.length < decimalDigits ) {
                         decimalString = decimalString + "0";
                     }
                     return formatInt(num, digitGroupSep, digitsInGroup) + decimalSep + decimalString;
                 }
                 return formatInt(num, digitGroupSep, digitsInGroup);
             }
             else {
                return "";
             }
         }
    }
 }

/**
 * formats an integer with correct digit grouping and
 * digit group char
 */
 function formatInt(intString, digitGroupSep, digitsInGroup) {
     if(intString.length <= digitsInGroup){
         return intString;
     }
     else {
         var strLen = intString.length;
         var numNotInGroup = strLen % digitsInGroup;
         var numDGChars = (strLen - numNotInGroup) / digitsInGroup;
         if(numNotInGroup == 0) {
             numDGChars -= 1;
         }
         for(var i = 1; i <= numDGChars; i++) {
             if(numNotInGroup == 0) {
                 index = (numDGChars-(i-1))*digitsInGroup;
             }else {
                 index = numNotInGroup+((numDGChars-i)*digitsInGroup);
             }
             intString = intString.substring(0,index)+digitGroupSep+intString.substring(index);

         }
         return intString;
     }
 }

function textField_onFocus() {
    focussedText = findJSOForElement(this);
}

function textField_onChange() {
    var obj = findJSOForElement(this);
    if (obj.element != null && obj.element.onValueChange != null && obj.element.onValueChange != "") {
        eval(obj.element.onValueChange);
    }
    obj.isValidated = false;
    obj.isValidating = true;
}

/**
 * Used for rules
 */
function textField_onBlur() {
    if(this.oldOnBlur!=null){
        this.oldOnBlur();
    }

    var undefined;
    val = null;
    if( this.value != null ) {
        val = this.value;
    } else {
        val = null;
    }

    // clear out the focussedAutoComp variable
    focussedText = undefined;
    var obj = findJSOForElement(this);
    if(!obj.isValidated){
        obj.dataMaskObject.handleIfFieldEmpty(this);
        //if an "object not defined error" happens here that means
        //the dataMaskObject is not properly set in the TextFieldJSObject constructor.
    }
    if( this.value != undef && this.value != null && this.value != '' ) {
       if( !obj.validate(true) ) {
           obj.isValidating = false;
           this.cachedValue = this.value;
           return;
       }
    }else if(obj.valueElement){
        obj.valueElement.value = '0.0..';
    }
    // reset the following variables after validation is done
    obj.isValidating = false;
    obj.isValidated = true;

    if(obj.RuleArray.length > 0) {
        if(this.cachedValue == undef && this.value != null) {
            if(trimString(this.value) != "") {
	            RuleUtil.isPendingFlag = true;
                RuleUtil.evaluateRules(obj.RuleArray, obj.getValue(), obj.isCodeString());
                this.cachedValue = this.value;
            }
        } else if( this.cachedValue != this.value ) {
            if( trimString(this.cachedValue) != trimString(this.value) ) {
	            RuleUtil.isPendingFlag = true;
                RuleUtil.evaluateRules(obj.RuleArray, obj.getValue(), obj.isCodeString());
            }
            this.cachedValue = this.value;
        }
    }else{
        RuleUtil.isPendingFlag = false;
        resumeOnclickEvents();
    }
}

/**
 *  Validate method for javascript text field object.
 */
function _validateTextField(forceCheck) {
    if (this.isEnabled == false) {
        // the component is not enabled, no need for validation, just return true
        return true;
    }
    this.element.value = trimString(this.element.value);
    //error if required and trimmed value matches empty value
    if(checkRequired && (this.required || (forceCheck != null && forceCheck)) &&
       (this.element.value==this.emptyString)) {
        requiredAlert(this.clLabel);
        return false;
    }

    //error if numeric and not a number
    if(this.isNumeric) {
        var numstr = this.element.value;
        var num = getNumberString(numstr, this.clLabel, this.numberFormattable);
        if(!num ) {
           return true;
        }
        if (num == NUM_NO_GROUP_SEP)
        {
            alert(formatMessage(containsGroupSeparator, this.clLabel));
            return false;
        }
        if((num == NUM_NON_FORMAT_CHARS || num == NUM_FORMAT_CHARS_INTERCHANGED) &&
            this.decimalPlaces == 0) {
            alert(formatMessage(noDecimalNumberMessage, this.clLabel));
            return false;
        }
        if(num == NUM_NON_FORMAT_CHARS) {
           alert(formatMessage(unrecognizedChar, this.clLabel));
           return false;
        }
        if(num == NUM_FORMAT_CHARS_INTERCHANGED) {
            alert(formatMessage(formatCharsInterchanged, this.clLabel));
            return false;
        }
        if(isNaN(num) == true) {
            alert(formatMessage(numericInvalidCharsMessage, this.clLabel));
            return false;
        }

        if(this.minimumNumberValue.length != 0) {
            if(num < this.minimumNumberValue){
               alert(formatMessage(belowMinimum, this.minimumNumberValue, this.clLabel));
               return false;
            }
        }
        if(this.maximumNumberValue.length != 0) {
            if(num > this.maximumNumberValue){
                alert(formatMessage(aboveMaximum, this.maximumNumberValue, this.clLabel));
                return false;
            }
        }

        if (this.decimalPlaces == 0) {
            // this value should not be a decimal number
            //if (this.element.value.indexOf('.') > -1) {
            if (num.indexOf('.') > -1) {
                alert(formatMessage(noDecimalNumberMessage, this.clLabel));
                return false;
            }
        }
        else {
            var index = this.element.value.indexOf(userDecimalSep);
            // if there is a decimal point then validate the no of decimal digits
            if (index > -1) {
                var numDecimalDigits = this.element.value.length - 1 - index;
                if (numDecimalDigits > this.decimalPlaces) {
                    alert(formatMessage(decimalDigitsExceededMessage, this.clLabel, this.decimalPlaces));
                    return false;
                }
                else if (numDecimalDigits == 0) {
                    // remove the trailing decimal point
                    this.element.value = this.element.value.substring(0, index);
                }
            }
        }
        this.element.value = formatNumber(num, this.numberFormattable);
    }
    return true;
}

/**
 *   returns the token of a text field
 */
function textField_getTokenValue(isVisible) {
    if(this.validate(true)) {
        returnValue = decode(this.valueElement.value, isVisible);
        codeValue = decode(this.valueElement.value, false);
        if (this.isBlankable && codeValue == BLANK_VALUE_CODE_STRING) {
          returnValue = "";
        }
    }else {
        returnValue = "";
    }
    return returnValue;
}

function textField_setValue(codeString, noCascade) {
    this.element.value = this.text_fmtValue(codeString);
    if( noCascade == undef || noCascade ) {
        this.element.cachedValue = this.element.value;
    }
}
function textField_fmtValue(codeString) {
    visibleValue = decode(codeString, true);
    if(visibleValue == null)
    {
        return this.emptyString;
    }
    else
    {
        visibleValue = visibleValue.replace(/\r\n/gi, "\n");
        return visibleValue;
    }
}

/**
 *  Set the isEnabled flag to false and the autocomplete image would grey out
 */
 function textField_setEnabled(flag){
    if(flag) {
        this.isEnabled = true;
        // set the field's disabled property to be false in IE & Netscape7
        this.element.disabled = false;
        this.element.className = this.defaultClass;
        // set the focus to that field
        //this.element.focus();
    } else {
        this.isEnabled = false;
        // in IE, just set the disabled property to be true, and change the style class to grey
        this.element.disabled = true;
        this.element.className = this.disabledClass;
    }
 }

/**
 * Sets the currency of a text field with a currency data mask
 */
function textField_setCurrency(newCurrencyId) {
  if (this.dataMaskObject instanceof CurrencyDM) {
    var numericValue = this.getTokenValue(false);
    this.dataMaskObject.currencyId = newCurrencyId;
    this.setValue(encode(numericValue, ''));
  }
}

/**
 * Set the required flag
 */
function generic_setRequired(flag){
   this.required = flag;
}

/**
 * Checks whether the value matches
 */
function textfield_chkValue(valArray, isCodeString) {
    if(valArray.length != 1) {
        return false; // There isn't a chance the values match
    }

    if(valArray == this.element.value) {
      return true;
    }

    return false;
}

function textfield_getValue() {
    return this.element.value;
}

/**
 * Returns the value element's value
 */
function textfield_getValueForRule() {
    return this.valueElement.value;
}

/**
 * Returns the value element's value
 */
function textField_clearValue() {
    checkRequired = false;
	this.setValue('');
	checkRequired = true;
}

/**
 *  TextField javascript object definition.
 *  Text field is still under construction - helen/harris
 */
//new
function TextField(label, element, valueElement, required, emptyString, tokenName,  visibleTokenName, dataMaskObject, form, onValueChange, isBlankable) {
    this.clLabel = label;
    this.name = element.name;
    this.valueElement = valueElement;
    this.element = element;
    this.element.cachedValue = element.value;
    this.required = required;
    this.emptyString = emptyString;
    this.defaultClass = this.element.className;
    this.disabledClass = "textareadisabled";
    this.focusable = true;
    this.RuleArray = new Array();
    this.element.onfocus = textField_onFocus;
    this.element.oldOnBlur = this.element.onblur;
    this.element.onblur = textField_onBlur;
    this.element.onchange = textField_onChange;
    this.element.onValueChange = onValueChange;
    if(tokenName != ""){
        new Token(tokenName, this, false, form);
    }
    if(visibleTokenName != ""){
        new Token(visibleTokenName, this, true, form);
    }

    this.isEnabled = true;
    this.isValidated = true;
    this.isValidating = false;
    this.isBlankable = isBlankable;
    if(dataMaskObject){
        //this "if" statement is needed since the first initialization will fail.
        this.dataMaskObject = dataMaskObject;
        this.element.onkeypress = this.dataMaskObject.elementHandleInput;
        this.validate = this.dataMaskObject.validate;
        this.setValue = this.dataMaskObject.tfSetValue;
        this.text_fmtValue = this.dataMaskObject.tfFmtValue;
        this.dataMaskObject.toggleColor(this.element, decode(this.valueElement.value,false));
        this.getRawNumber = this.dataMaskObject.getRawNumber;
    }
}
new TextField("","","","","","","",false,"","", false);
TextField.prototype.addListener = rules_addListener;
TextField.prototype.getTokenValue = textField_getTokenValue;
TextField.prototype.getLabel = getLabel;
TextField.prototype.setEnabled = textField_setEnabled;
TextField.prototype.setRequired = generic_setRequired;
TextField.prototype.chkValue = textfield_chkValue;
TextField.prototype.getValue = textfield_getValue;
TextField.prototype.getValueForRule = textfield_getValueForRule;
TextField.prototype.isCodeString = no_codestring;
TextField.prototype.setCurrency = textField_setCurrency;
TextField.prototype.clearValue = textField_clearValue;

/**
 *  END TEXTFIELD OBJECT
 */

function formatCurrency(value) {
    return formatNumber(value, true, 2, true, true);
}

/**
 * BEGIN DRIVENFIELD OBJECT
 */
/**
 * A DrivenField is like a TextField crossed with an AutoComplete, except that its value cannot be
 * updated by the user. It can only be driven by another field in the form.
 */

var TEXTFIELD           = 1;
var COMBOBOX            = 2;
var YES_NO              = 3;
var AUTO_COMPLETE       = 4;
var TEXTAREA            = 5;
    // 6 was HIDDEN, but has been removed in this version
var DATE                = 7;
var URL                 = 8;
var FILE_CHOOSER        = 9;
var DIRECTORY_CHOOSER   = 10;
var ATTACHMENT          = 11;
var PASSWORDBOX         = 12;

function driven_setValue(codeString) {
    visibleValue = decode(codeString, true);
    switch(this.fieldType) {
        case 7:  // DATE
            document.getElementById(this.divID).innerHTML = this.date_fmtValue(visibleValue);
            break;
        case 1:  // TEXTFIELD
            var obj = document.getElementById(this.divID);
            var formattedValue = this.dataMaskObject.fmtValue(decode(codeString, true));
            var oldValue = this.valueElement.value;
            if (this.text_setValue(codeString)) {
                obj.innerHTML = formattedValue;
            } else {
                codeString = oldValue;
            }
            break;
        case 5:  // TEXTAREA
            document.getElementById(this.divID).innerHTML = this.text_fmtValue(codeString);
            break;
        case 3:  // YES/NO
            if(visibleValue == 'Y') {
                document.getElementById(this.divID).innerHTML = this.yes;
            }
            else if (visibleValue == 'N') {
                document.getElementById(this.divID).innerHTML = this.no;
            }
            break;
        case 8: // URL;
            var theURL = decode(codeString, false);
            var innerHTMLValue = null;
            var theURLTitle = decode(codeString, true);
            if (theURLTitle==null)
                theURLTitle=theURL;

            if(theURL.indexOf('://') == -1 && theURL.indexOf('testdirector:') == -1) {
            	innerHTMLValue = '<a href="http://' + theURL + '">' + theURL + '</a>';
            } else {
              	innerHTMLValue = '<a href="' + theURL + '">' + theURLTitle + '</a>';
            }
            document.getElementById(this.divID).innerHTML = innerHTMLValue;
            break;
        case 19: // LINK;
                    var theURL = decode(codeString, false);
                    var innerHTMLValue = null;
                    var theURLTitle = decode(codeString, true);
                    if (theURLTitle==null)
                        theURLTitle=theURL;

                    innerHTMLValue = "<a class='show-link' href=\"javascript:gotoUrlRefs('" + theURL + "');\">" + theURLTitle + "</a>";
                    document.getElementById(this.divID).innerHTML = innerHTMLValue;
                    break;
        default:

            if(visibleValue == null) {
                document.getElementById(this.divID).innerHTML = this.emptyString;
            }
            else {
                document.getElementById(this.divID).innerHTML = visibleValue;
            }
            break;
    }
    this.currentCSValue = codeString;
    if(this.dataMaskObject){
        this.dataMaskObject.setValueElement(this.valueElement.value, decode(codeString, false), decode(codeString, true));
    }else{
        this.valueElement.value = codeString;
    }
}

function driven_getValue() {
    return this.valueElement.value;
}

function _validateDriven(forceCheck) {
    if((this.required == true || (forceCheck != null && forceCheck)) &&
       (this.currentCSValue == this.emptyString)) {
        requiredAlert(this.clLabel);

        return false;
    }
    return true;
}

function driven_getTokenValue(isVisible){
    if(this.fieldType == TEXTFIELD) {
        if(!this.isNumeric) {
            if(this.validate(true)) {
                return decode(this.valueElement.value, isVisible);
            }else {
                return "";
            }
        }else {
            if(this.validate(true)) {
                return decode(getNumberString(trimString(this.valueElement.value)), isVisible);
            }else {
                return "";
            }
        }
    }
    else if (this.fieldType == DATE) {
        if(this.validate(true)){
            return decode(this.valueElement.value, false); // For dates always return the code.
        } else {
            return "";
        }
    }
    else {
        if(this.validate(true)){
            value = decode(this.valueElement.value, isVisible);
            if(value == null){
                return "";
            }else{
                return value;
            }
        }else{
            return "";
        }
    }
}

// This function will move the focus to the next field in the form, skipping fields that shouldn't take the
// focus (Hidden and Driven fields).
// This function should be called especially if there is an attempt to place the focus on a driven field.
// Parts of this function were lifted from the setInitialFocus function in the global template.
function findFocus(focusElement) {
    var found = false;
    var focussed = false;
    // Note: We need to iterate through all forms (not just the one the element is in) because
    // focus may shift to a new form later in the page.
    for ( i=0 ; i<document.forms.length ; i++ ) {
        if ( document.forms[i].elements != null ) {
            currElements = document.forms[i].elements;
            for ( j=0 ; j<currElements.length ; j++ ) {
                element = currElements[j];
                if(found==false) {
                    if (element == focusElement) {
                        found = true;
                    }
                }
                else {
                    if(element.focus != null) { // This means we can focus on it.
                        if( element.type != null && element.type != 'hidden' ) { // Don't focus on a hidden element.
                            var obj = findJSOForElement(element);

                            if( obj != null ) { // There is an associated object.
                                if ( obj.focusable == null || obj.focusable == true ) { // Check if object allows focus.
                                    element.focus();
                                    focussed = true;
                                    break;
                                }
                            } else { // The element is focussable but has no object associated with it.
                                element.focus();
                                focussed = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        if(focussed == true) {
            break;
        }
    }
}

function DrivenField_onfocus() {
    this.blur();
    findFocus(findJSOForElement(this));
    return true;
}

function DrivenField(label,
                     element,
                     valueElement,
                     divID,
                     csValue,
                     emptyString,
                     tokenName,
                     visibleTokenName,
                     fieldType,
                     dataMaskObject,
                     isNumeric,
                     decimalPlaces,
                     numberFormattable,
                     dateStyle,
                     timeStyle,
                     yes,
                     no,
                     form) {
    this.clLabel = label;
    if(element) {
        this.name = element.name;
        this.element = element;
    } else {
        this.element = null;
    }
    this.valueElement = valueElement;
    this.divID = divID;
    this.focusable = false;
    // Set this element to blur whenever it receives focus.  For both IE and NN4 this makes
    // the element read only to the user.
    if(element) {
        element.onfocus = DrivenField_onfocus;
    }
    this.emptyString = emptyString;
    this.currentCSValue = csValue;
    this.fieldType = fieldType;
    this.isNumeric = isNumeric;
    this.decimalPlaces = decimalPlaces;
    this.numberFormattable = numberFormattable;
    this.dateStyle = dateStyle;
    this.timeStyle = timeStyle;
    this.yes = yes;
    this.no = no;

    if(tokenName != ""){
        new Token(tokenName, this, false, form);
    }
    if(visibleTokenName != ""){
        new Token(visibleTokenName, this, true, form);
    }

    if(dataMaskObject){
        this.isValidated = true; //this is always true;
        this.dataMaskObject = dataMaskObject;
        this.element.onkeypress = this.dataMaskObject.elementHandleInput;
        this.validate = this.dataMaskObject.validate;
        this.getTokenValue = textField_getTokenValue;
        this.text_setValue = this.dataMaskObject.tfSetValue;
        this.text_fmtValue = this.dataMaskObject.tfFmtValue;
        this.divObj = document.getElementById(this.divID);
        this.dataMaskObject.toggleColor(this.divObj, decode(this.valueElement.value, false));
        this.getRawNumber = this.dataMaskObject.getRawNumber;
    }
    this.formName = form;
}

//REQUEST#137594 only used for date driven fields
function drivenField_setValueElement(timestamp) {
    switch(this.fieldType) {
        case 7:  // DATE
            document.getElementById(this.divID).innerHTML = this.element.value;
            this.valueElement.value = timestamp;
    };
}

new DrivenField("", "", "", "", "", "", "", false, "", false, "");
DrivenField.prototype.validate = _validateDriven;
DrivenField.prototype.getTokenValue = driven_getTokenValue;
DrivenField.prototype.getValue = driven_getValue;
DrivenField.prototype.getValueForRule = driven_getValue;
DrivenField.prototype.setValue = driven_setValue;
DrivenField.prototype.getLabel = getLabel;
DrivenField.prototype.date_setValue = dateField_setValue;
DrivenField.prototype.date_fmtValue = dateField_fmtValue;
DrivenField.prototype.text_setValue = textField_setValue;
DrivenField.prototype.text_fmtValue = textField_fmtValue;
DrivenField.prototype.isNotEmpty = rules_isNotEmpty;
DrivenField.prototype.chkValue = rules_chkValue;
DrivenField.prototype.formatDateOnServer = dateField_formatDateOnServer;
DrivenField.prototype.setValueElement = drivenField_setValueElement;
DrivenField.prototype.callBack = dateField_callBack;

/**
 *  BEGIN YESNORADIOBUTTON OBJECT
 */
/**
 *  Validate method for the radiobutton object.
 *  Allows for blank if not required
 */
function _validateYesNoRadioButton() {
    //error if required and neither button is checked
    if(checkRequired && (this.required) && (this.first.checked!=true) &&
       (this.second.checked!=true)) {
        requiredAlert(this.clLabel);

        return false;
    }
    return true;
}

/**
 *  Retrieves the token value of this radio button object.
 */
function yesnoradioButton_getTokenValue(){
    if(this.first.checked==true){
        return "Y";
    }else{
        return "N";
    }
}

function yesnoradioButton_setValue(value) {
    if(value == undef || value == '') {
        // do nothing
        return;
    }
    if(value == '1.1.Y.Y' || value == 'Y') {
        this.first.checked = true;
    } else {
        this.second.checked = true;
    }
}

function yesnoradioButton_getValue() {
    if( this.first.checked ) {
        return "Y";
    } else {
        return "N";
    }
}

function yesnoradioButton_getChanged() {
    changed = false;
    if( this.first.checked && (this.cachedValue == "N" || this.cachedValue == "") ) {
        this.cachedValue = "Y";
        changed = true;
    } else if( this.second.checked && (this.cachedValue == "Y" || this.cachedValue == "") ) {
        this.cachedValue = "N";
        changed = true;
    }
    return changed;
}

function yesnoradioButton_onclick(group) {
    var obj = findJSOForElement(group);
    // this is called when either of the buttons clicked, regardless of
    // whether this button was already selected
    changed = obj.getChanged();
    if( changed ) {
        // then check RuleArray
        if( obj.getRuleArray() && obj.getRuleArray().length > 0 ) {
            RuleUtil.isPendingFlag = true;
            RuleUtil.evaluateRules(obj.getRuleArray(), obj.getValue(), obj.isCodeString());
        }
    }
}

function yesnoradioButton_getRuleArray() {
    return this.RuleArray;
}

/**
 *  Set the isEnabled flag to false and the yes/no button will no logner work
 */
 function yesnoradioButton_setEnabled(flag){
    if(flag) {
        this.isEnabled = true;
        this.first.disabled = false;
        this.second.disabled = false;

        // set the focus to that field
        // this.first.focus();
    } else {
        this.isEnabled = false;
        // in IE, just set the disabled property to be true
        this.first.disabled = true;
        this.second.disabled = true;
    }
 }

/**
 *  RadioButton javascript object definition.
 */
function YesNoRadioButton(label, element0, element1, required, tokenName,  visibleTokenName, form) {
    this.clLabel = label;
    //both have the same name. That's why they're in an array
    this.name = element0.name;

    this.first = element0;
    this.second = element1;
    this.required = required;
    this.RuleArray = new Array();

    this.cachedValue = "";
    if( this.first.checked ) {
        this.cachedValue = "Y";
    } else if( this.second.checked ) {
        this.cachedValue = "N";
    }

    if(tokenName != ""){
        new Token(tokenName, this, false, form);
    }
    if(visibleTokenName != ""){
        new Token(visibleTokenName, this, true, form);
    }
}

new YesNoRadioButton("", "", "", false, "", "");
YesNoRadioButton.prototype.addListener = rules_addListener;
YesNoRadioButton.prototype.validate = _validateYesNoRadioButton;
YesNoRadioButton.prototype.getTokenValue = yesnoradioButton_getTokenValue;
YesNoRadioButton.prototype.getLabel = getLabel;
YesNoRadioButton.prototype.setValue = yesnoradioButton_setValue;
YesNoRadioButton.prototype.getValue = yesnoradioButton_getValue;
YesNoRadioButton.prototype.getValueForRule = yesnoradioButton_getValue;
YesNoRadioButton.prototype.isCodeString = no_codestring;
YesNoRadioButton.prototype.setEnabled = yesnoradioButton_setEnabled;
YesNoRadioButton.prototype.getChanged = yesnoradioButton_getChanged;
YesNoRadioButton.prototype.setRequired = generic_setRequired;
YesNoRadioButton.prototype.getRuleArray = yesnoradioButton_getRuleArray;

/**
 *  END YESNORADIOBUTTON OBJECT
 */

 /**
 *  BEGIN CHECKBOX OBJECT
 */

/**
 *  Retrieves the token value of this radio button object.
 */
function checkBox_getTokenValue(){
    if(this.checked==true){
        return "Y";
    }else{
        return "N";
    }
}

/**
 *  Set the isEnabled flag to false and the checkBox will no longer work
 */
 function checkBox_setEnabled(flag){
    if(flag) {
        this.isEnabled = true;
        // set the field's disabled property to be false in IE & Netscape7
        this.element.disabled = false;
    } else {
        this.isEnabled = false;
        // in IE, just set the disabled property to be true
        this.element.disabled = true;
    }
 }

/**
 *  CheckBox javascript object definition.
 */
function CheckBox(label, element, tokenName,  visibleTokenName, form) {
    //both have the same name. That's why they're in an array
        this.clLabel = label;
        this.element = element;
    this.name = element.name;

    if(tokenName != ""){
        new Token(tokenName, this, false, form);
    }
    if(visibleTokenName != ""){
        new Token(visibleTokenName, this, true, form);
    }

        this.isEnabled = true;
}

new CheckBox("", "", "", "");
CheckBox.prototype.getTokenValue = checkBox_getTokenValue;
CheckBox.prototype.setEnabled = checkBox_setEnabled;

/**
 *  END CHECKBOX OBJECT
 */

/**
 *  BEGIN AUTOCOMPLETE OBJECT
 */
/**
 *  Validate method for this autocomplete object.
 */
function _validateAutoComplete(forceCheck) {
    if (this.isEnabled == false) {
        // the component is not enabled, no need for validation, just return true
        return true;
    }
    if(checkRequired && (this.required == true || (forceCheck != null && forceCheck)) &&
       (this.currentCSValue == this.emptyString ||
        this.currentCSValue == this.blankCodeString ||
        this.currentCSValue == "" ||
        trimString(decode(this.currentCSValue, true)) == "" )) {
         requiredAlertAutoComp(this.clLabel);

         return false;
    }
    if(this.dirtyFlag == true) {
        this.onclick(this.element.value);
        return false;
    }
    // if the autocomplete's value has never been validated
    // as indicated by a blank code and a non-blank meaning
    if (trimString(decode(this.currentCSValue, false)) == "" &&
        trimString(decode(this.currentCSValue, true)) != "") {
        /**
         * Request #102319 - need to check for showAlert before displaying the warning
         * in case _validateAutoComplete() was called from resolvePageTokens()
         */
        if (showAlert) {
            alert(formatMessage(invalidMessage, this.clLabel));
        }

        return false;
    }

    return true;
}

/**
 *  returns the value of this autocomplete object.  The isVisible flag specifies
 *  the visible (true) or the hidden (false) value.
 */
function autoComplete_getTokenValue(isVisible){
    if(this.validate(true)){
        visibleValue = decode(this.currentCSValue, isVisible);
        codeValue = decode(this.currentCSValue, false);
        if(visibleValue == null){
            return "";
        }else{
            if (this.isBlankable && codeValue == BLANK_VALUE_CODE_STRING) {
              return "";
            }
            return visibleValue;
        }
    }else{
        return "";
    }
}

/**
 *  sets the value of the autocomplete object with newCSValue.
 */
function autoComplete_setValue(newCSValue, noCheckChange){
    previousCSValue = this.currentCSValue;
    if(newCSValue != null){
        this.currentCSValue = newCSValue;
    } else{
        this.currentCSValue = this.emptyString;
    }

    this.dirtyFlag = false;
    if(noCheckChange == undef || noCheckChange == false) {
        this.resetDefaults( previousCSValue );
    }
    this.resetValue();
    if(this.onValueChange != "") {
       eval(this.onValueChange);
    }
}

/**
 *  triggers the reset of the defaul values of the html components according
 *  to the value of autocomplete type component.
 *  This method returns if the value of the AC changed.
 */
function autoComplete_resetDefaults( previousCSValue )
{
    if ( this.currentCSValue == previousCSValue )
    {
        RuleUtil.isPendingFlag = false;
        isAutoCompVerifying = false;
        return;
    }

    if(this.RuleArray.length > 0) {
        RuleUtil.evaluateRules(this.RuleArray, this.getValue(), this.isCodeString());
    }
}

/**
 * gets the CodeString value of the autocomplete.
 */
function autoComplete_getValue() {
    return this.currentCSValue;
}

/**
 *  resets the visible value of the html component to whatever
 *  is the stored value.
 */
function autoComplete_resetValue(){
    visibleValue = decode(this.currentCSValue, true);
    if(visibleValue == null){
        this.element.value = this.emptyString;
    }else{
        this.element.value = visibleValue;
    }
    this.valueElement.value = this.currentCSValue;
}

var changeFlag = false;
function resetChangeFlag() {
	changeFlag = false;
}

/**
 *  When there's a change in the autocomplete textfield
 *  this function is called.
 *  onchange function name change since for mozilla browsers onchange()
 *  function is a reserve function.
 */
function autoComplete_onchange() {
    changeFlag = true;
    if (clickCheckFlag) {
        this.value = ""; // clear culltext
        changeFlag = false;
        return;
    }
    setTimeout('resetChangeFlag()', 1000);
	
    var undefined;
    focussedAutoComp = undefined;
    var obj = findJSOForElement(this);

    if(this.value != ""){
      obj.dirtyFlag = true;
      if(obj.tabeventx && obj.tabeventy) {
	      if(window.event) {
	        obj.tabeventx=window.event.screenX;
	        obj.tabeventy=window.event.screenY;
	      } else {
	        obj.tabeventx=100;
	        obj.tabeventy=100;
	      }
      }

      // check to see if auto-complete popup window is open
      // if it is, reset it and close out the previous auto-complete
      if (popup != null && popup != undefined && !popup.closed) {
      	 // popup window is open
      	 // now to check if it is an auto-complete window
      	 if (popup.window.closeWindoid != null && popup.window.closeWindoid != undefined) {
      	 	 if (popup.window.name == obj.name + ACPopupNamePostFix) {
      	 	   // same field, do not clear out cull text
          	 popup.window.closeWindoid(true);
      	 	 } else {
      	 	 	 // different field, clear out cull text
      	 	 	 popup.window.closeWindoid();
      	 	 }
      	 }
      }

      /**
       * if auto-complete is not command validated, then we want to pre-verify
       * otherwise, we want to call onclick().
       */
        if (!obj.isCmdValidation) {
          obj.preVerify(this.value);
        } else {
          // For netscape, we open the autocomplete window with a timeout call.
          // The timeout is only used because this gets around a bug in Netscape 7
          // which causes windows opened from an onblur call to get opened
          // underneath the parent window.  This esentially creates a new thread
          // to open the window in, getting around that limitation.
          var cullTextValue = this.value;
          if (cullTextValue) {
            // Replace backslash and double quote to prevent the constructed
            // string call from being broken.
            cullTextValue = cullTextValue.replace(/\\/g, '\\\\');
            cullTextValue = cullTextValue.replace(/\"/g, '\\"');
          }

          // Schedule the onclick method to be called immediately.
          var onClickCall = 'window.' + obj.formName + '.' + obj.name + '.onclick("' + cullTextValue + '")';
          setTimeout(onClickCall, 20);
        }
    }else{
        obj.dirtyFlag = false;
        obj.setValue(this.blankCodeString);
    }
    return true;
}

/**
 * The following variable is used in the Search page. When user hit
 * "Enter/Return" key, it needs to first validate the autocomplete
 * before any Search happens.
 */
function onfocussed() {
    focussedAutoComp = findJSOForElement(this);
}

/**
 * When onblurred event happens, it needs to validate what user has
 * typed in. For IE 5.5+, we can use to backend validation to do the
 * work; but for all other browsers, we need to call onclick() to
 * handle it because the backend validation doesn't work in those
 * browsers (also RuleUtils would not work in that case). We should
 * come back to it in future release to see if we can find a better
 * fix for this.
 */
function onblurred(){
   // ELL: This function no longer does anything.  All its code has been moved to
   // onchange().  The reason: onblurred() assumed that onchange() would be called
   // before it, as it depended on the dirtyFlag being true.  However, there is no
   // guarantee on the order of these calls.  Since onchange() is the only place
   // to set dirtyFlag to true, it follows that it should just perform the onblurred() code.
}

function disableClicks(evt) {
    return false;
}

/**
 *  the method is called whenever a user clicks Ok button
 *  in the autocomplete popup dialog.
 */
function ac_popup_onclick(){
    element = window.opener.document[window.name];
    handleSelections(element);
    ac_window_close(element);
}

// Handle closing an auto complete window. Check to make sure that we call back to ruleutil when
// window closes.
function ac_window_close(element) {
    // The Iframe.callback() has been moved to the
    // the AutocompPreverify.jsp before the onclick method is
    // called since this method does not get called
    // when the autocomplete is closed before it is loaded. see bug#122205 - 07/21/03

    // Since the auto-complete has finished verifying
    // Set the global isAutoCompVerifying flag to false.
    srcparent.isAutoCompVerifying = false;
    srcparent.popup = null;
    window.close();
}



/**
 * generate codestring from all the selections if any, called by ac_popup_onclick();
 * also called by the AutocompPreVerify.jsp
 */
function handleSelections(element, selectedCodeStrings, drivenFieldArray) {
    var undefined;
    var valAry;
    if (element == undefined) {
        srcparent.isAutoCompVerifying = false;
        return;
    }
    // Making an assumption that the driving fields are always in the first form on the page.
    // In order to support driving fields on any form within a page, we need to develop a more
    // sophisticated mechanism to determine what form a given driving element is in. -GS
    parentForm = element.form;

    if (parentForm != undefined && parentForm[element.name] != undefined) {
        var obj = findJSOForElement(parentForm[element.name]);

        if(obj == null) {
          isDriving = false;
          drivenFields = undefined;
        } else {
          isDriving = obj.isDrivingFlag;
          drivenFields = obj.drivenFields;
          drivenFieldsCallback = obj.acCallback;
        }
    } else {
        drivenFields = undefined;
        isDriving = false; //assume not a driven field
    }

    // Check if this element has Rules.
    // If so set the pending flag to true,
    // so that rules are fired before we save.
    // This flag is reset by the RuleUtil.callback.
    if( element.RuleArray.length > 0 ) {
        srcparent.RuleUtil.isPendingFlag = true;
    }

    // set the value

    element.setValue(selectedCodeStrings);

    if (selectedCodeStrings != null && selectedCodeStrings != "") { // means something was selected

      // handle driving fields
      if(isDrivingField(element.name, isDriving)) {
        handleDrivingFields(element, drivenFieldArray, drivenFields, drivenFieldsCallback);
      }
    } else {
      // nothing was selected
      if(isDrivingField(element.name, isDriving)) {
        handleDrivingFields(element, null, drivenFields, drivenFieldsCallback);
      }
    }

    drivenFieldArray = null; // Assist the garbage collection.
    srcparent.isAutoCompVerifying = false;
}

/**
 * Returns true if fieldName can drive the values of other fields.
 */
function isDrivingField(fieldName, isDrivingFlag) {
    if (   fieldName == 'CONTACT_NAME_ID'
        || fieldName == 'CONTACT_EMAIL'
        || fieldName == 'CONTACT_PHONE_NUMBER'
        || fieldName == 'WF_ACTION_CONTACT_NAME_ID'
        || fieldName == 'WF_ACTION_CONTACT_EMAIL'
        || fieldName == 'WF_ACTION_CONTACT_PHONE_NUMBER'
        || isDrivingFlag) {
        return true;
    } else {
        return false;
    }
}
/**
 * If changes to one autocomplete field drive changes in another,
 * this function will handle the logic.
 */
function handleDrivingFields(element, valArray, drivenFields, drivenFieldsCallback) {
    // We have to determine the form array so we can manipulate the elements in it.
    var undefined;
    formAry = undefined;
    var parent;
    if(window.opener != undefined) {
        parent = window.opener;
    } else {
        parent = window.parent;
    }

    if(parent.document.rdf != undefined) {
        formAry = parent.rdf;
    }
    else if(parent.document.RequestCreateForm != undefined) {
        formAry = parent.RequestCreateForm;
    }

    if (drivenFields != undefined) {
        drivenFieldsAry = drivenFields.split(MULTIAUTO_DELIMITER);
        aryLength = drivenFieldsAry.length;
        if (valArray != undefined) {
            valAryLength = valArray.length;
            var value, name;
            for (i=1; i<valAryLength; i++) {
                value = valArray[i];
                name = drivenFieldsAry[i-1];
                if (drivenFieldsCallback != null){
                    drivenFieldsCallback(name, value);
                }
            }
        }
    }

    // Be careful.  Other products may use contacts but not do driving.
    if(formAry != undefined) {
        if(element.name == 'CONTACT_NAME_ID' || element.name == 'WF_ACTION_CONTACT_NAME_ID') {
            var contactPhone = (element.name == 'CONTACT_NAME_ID') ? formAry.CONTACT_PHONE_NUMBER : formAry.WF_ACTION_CONTACT_PHONE_NUMBER;
            var contactEmail = (element.name == 'CONTACT_NAME_ID') ? formAry.CONTACT_EMAIL : formAry.WF_ACTION_CONTACT_EMAIL;
            if(valArray == null) {
                _doSetValue(contactPhone, element.emptyString);
                _doSetValue(contactEmail, element.emptyString);
            } else {
                _doSetValue(contactPhone, valArray[1]);
                _doSetValue(contactEmail, valArray[2]);
            }
        }
        else if(element.name == 'CONTACT_EMAIL' || element.name == 'WF_ACTION_CONTACT_EMAIL') {
            var contactName = (element.name == 'CONTACT_EMAIL') ? formAry.CONTACT_NAME_ID : formAry.WF_ACTION_CONTACT_NAME_ID;
            var contactPhone = (element.name == 'CONTACT_EMAIL') ? formAry.CONTACT_PHONE_NUMBER : formAry.WF_ACTION_CONTACT_PHONE_NUMBER;
            if(valArray == null) {
                _doSetValue(contactName, element.emptyString);
                _doSetValue(contactPhone, element.emptyString);
            } else {
                _doSetValue(contactName, valArray[1]);
                _doSetValue(contactPhone, valArray[2]);
            }
        }
        else if(element.name == 'CONTACT_PHONE_NUMBER' || element.name == 'WF_ACTION_CONTACT_PHONE_NUMBER') {
            var contactName = (element.name == 'CONTACT_PHONE_NUMBER') ? formAry.CONTACT_NAME_ID : formAry.WF_ACTION_CONTACT_NAME_ID;
            var contactEmail = (element.name == 'CONTACT_PHONE_NUMBER') ? formAry.CONTACT_EMAIL : formAry.WF_ACTION_CONTACT_EMAIL;
            if(valArray == null) {
                _doSetValue(contactName, element.emptyString);
                _doSetValue(contactEmail, element.emptyString);
            } else {
                _doSetValue(contactName, valArray[1]);
                _doSetValue(contactEmail, valArray[2]);
            }
        }
    }
}

/**
 * helper routine wrapped around set value functions to make sure
 * the element exists before setting a value to it.
 */
function _doSetValue(formElement, value) {
    var undefined;
    if(formElement != undefined) {
        formElement.setValue(value);
    }
}

/**
 *  Closes the popup window.
 */
function popup_close(){
    var undefined;
    if (window.opener.document[window.name] != undefined) {
        if (window.opener.document[window.name].dirtyFlag) {
            window.opener.document[window.name].setValue(window.opener.document[window.name].emptyString);
        }
    }
    // Set the popup variable on the parent window to null
    // as this variable is used to keep track if the child popup
    // window is closed so that we can determine if the autocomplete
    // popup was closed before it was loaded so that we can reset the
    // isAutoCompVerifying Flag to false in that case. see Request#115397
    srcparent.popup = null;
    ac_window_close(window.opener.document[window.name]);
}

/**
 *  Closes the popup window and Clears the autocomplete component.
 */
function popup_closeAndClear(){
    ac_window_close(window.opener.document[window.name]);
    window.opener.document[window.name].setValue(window.opener.document[window.name].emptyString);
}

/**
 *  Set the isEnabled flag to false and the autocomplete image would grey out
 */
 function autoComplete_setEnabled(flag){
    var imageObj = document[this.autocompleteName];
    var rscFindObj = document[this.rscFindImg];
    if(imageObj==null){
        alert('Internal Error: The image ' + this.autocompleteName + ' is missing.');
    }
    if(flag) {
        this.isEnabled = true;
        if (this.isUserAutoComplete) {
            //document.getElementById(this.autocompleteName).src = userAutoCompImgSrc; //works for IE but not netscape
            //document[this.autocompleteName].src = userAutoCompImgSrc; //works for IE and netscape except in the lookahead page
            imageObj.src = userAutoCompImgSrc;
            if(rscFindObj != null) {
                rscFindObj.src = rscFindImgSrc;
            }
        } else {
            //document.getElementById(this.autocompleteName).src = autoCompImgSrc;
            //document[this.autocompleteName].src = autoCompImgSrc;
            imageObj.src = autoCompImgSrc;
        }
        // set the field's disabled property to be false in IE & Netscape7
        this.element.disabled = false;
        this.element.className = this.defaultClass;
    } else {
        this.isEnabled = false;
        if (this.isUserAutoComplete) {
            //document.getElementById(this.autocompleteName).src = userAutoCompDisabledImgSrc;
            //document[this.autocompleteName].src = userAutoCompDisabledImgSrc;
            imageObj.src = userAutoCompDisabledImgSrc;
            if(rscFindObj != null) {
                rscFindObj.src = rscFindDisabledImgSrc;
            }
        } else {
            //document.getElementById(this.autocompleteName).src = autoCompDisabledImgSrc;
            //document[this.autocompleteName].src = autoCompDisabledImgSrc;
            imageObj.src = autoCompDisabledImgSrc;
        }
        // in IE, just set the disabled property to be true, and change the style class to grey
        this.element.disabled = true;
        this.element.className = this.disabledClass;
    }
 }

/**
 * This method pre-verify the autocomplete to check if there is only one row
 * returned. The logic is run in IFrame.
 */
function autoComplete_preVerify(cullText){
    if (this.isEnabled && !(this.isCmdValidation)) {
        this.isVerifying = true;
        // Set the global verifying flag to true.
        // It is reset back to false after the handleSelections method.
        isAutoCompVerifying = true;

        var objectName = this.name + ACPopupNamePostFix;
        //resolveTokens should always comes first because if the tokens are
        //unresolved it will just exit. Setting the windowIsOpen
        //should be done after this statement.
        if (this.isFieldFilterValidation) {
        	tokens = resolveTokensQuiet(this.tokens,this.form.name);
        } else {
        	tokens = resolveTokens(this.tokens, this.form.name);
        }
        if(tokens == UNRESOLVED){
            isAutoCompVerifying = false;
            this.isVerifying = false;
            return;
        }

        document[objectName] = this;
        // check if there is request id context
        var undefined;
        var requestIDContext;
        var requestDetailIDContext;
        var taskIDContext;
        var packageIDContext;
        if(this.form.REQUEST_ID_CONTEXT == undefined){
            requestIDContext = "";
        } else {
            requestIDContext = "&REQUEST_ID_CONTEXT="+ this.form.REQUEST_ID_CONTEXT.value;
        }
        if(this.form.REQUEST_DETAIL_ID_CONTEXT == undefined){
            requestDetailIDContext = "";
        } else {
            requestDetailIDContext = "&REQUEST_DETAIL_ID_CONTEXT="+ this.form.REQUEST_DETAIL_ID_CONTEXT.value;
        }
        if (this.form.TASK_ID_CONTEXT == undefined) {
            taskIDContext = "";
        } else {
            taskIDContext = "&TASK_ID_CONTEXT=" + this.form.TASK_ID_CONTEXT.value;
        }
        if (this.form.PACKAGE_ID_CONTEXT == undefined) {
            packageIDContext = "";
        } else {
            packageIDContext = "&PACKAGE_ID_CONTEXT=" + this.form.PACKAGE_ID_CONTEXT.value;
        }
        var cullString = "";
        if(cullText != null){
            cullString = "&CULL_TEXT=" + encodeURIComponent(cullText);
        }
        var currentSelectString = "";
        /**
         * we should not be keeping the previous selections because:
         * 1. the controller will rerunning the queries for each sub-cullstring anyway
         * 2. preVerify is called when user tabs out of the field after makign changes to it,
         *    so the previous choices are not valid any way.
         *
         * note: on_click() should drop the previous selections only if the text fied was modified
         */
        //currentSelectString = "&CURRENT_SELECT_TEXT=" + cl_escape(this.currentCSValue);
        currentSelectString = "&CURRENT_SELECT_TEXT=" + cl_escape(this.blankCodeString);

        // we need to decide whether it is a multi-select or single-select autocomplete
        var isMultiString = "N";
        if(this.isMulti)
            isMultiString = "Y";

        // now we can forward to the AutoCompPopupHandler
        var isDriving = isDrivingField(this.name, this.isDrivingFlag);
        var parameters = requestIDContext +
                         requestDetailIDContext +
                         taskIDContext +
                         packageIDContext +
                         cullString +
                         currentSelectString +
                         "&FIELD_NAME=" + encodeURIComponent(this.name) +
                         "&FIELD_LABEL=" + encodeURIComponent(this.clLabel) +
                         "&IS_MULTI=" + isMultiString +
                         "&KEY=" + getUniqueKey() +
                         "&TOKENS=" + encodeURIComponent(tokens) + // use cl_escape to escape any '+'s in outer joins
                         "&TOKEN_NAMES=" + encodeURIComponent(this.tokens) + // use cl_escape to escape any '+'s in outer joins
                         "&VALIDATION_ID=" + escape(this.validationId) +
                         "&FORM_NAME=" + escape(this.form.name) +
                         "&OK_TO_PARSE_CUll_STRING=" + this.isMulti +
                         "&IS_DRIVING_FLAG=" + isDriving +
                         "&IS_BLANKABLE=" + this.isBlankable;
        if (encodeServletParams) {
            newLoc = getHostPath() + autoCompPreVerifyServlet + encodeURIComponent(parameters);
        } else {
            newLoc = getHostPath() + autoCompPreVerifyServlet + parameters;
        }

        var ptxt = '';
        for (var i = 0; i < newLoc.length; i += 30) {
            ptxt = ptxt + '\n' + newLoc.substring(i, Math.min(newLoc.length, i+30));
        }

         //THIS IS A HACK
         //There's some kind of race condition in the autocompletes for Netscape.
         setTimeout('IFrame.setSrc(newLoc)', 100);
    }
    return;
}

var clickCheckFlag = false;
function resetClickCheckFlag() {
	clickCheckFlag = false;
}

/**
 *  This method is called whenever a user clicks on the autocomplete icon.
 *  It tries to see if the user has changed the autocomplete text field
 *  content; if yes, it means the onblurred event happens and we should not
 *  call the onclick() method (onblurred will call it);
 *  if no; it means user normally clicks on the icon, and we should open
 *  the dialog.
 *  This check prevents any race condition between onclick event and onblurred
 *  event, which could mess up the functionality of autocomplete in Netscape
 *  and IE 4 and 5.0 browsers.
 */
function autoComplete_onclickCheck() {
    clickCheckFlag = true;
    if (changeFlag) {
        clickCheckFlag = false;
        return;
    }
    setTimeout('resetClickCheckFlag()', 1000);
	
    if (!this.dirtyFlag) {
        this.onclick();
    }
    return;
}

/**
 *  make the popup window as a global variable
 */
var popup = null;
var newLoc = null;

/**
 *  this method is called indirectly by both onclickCheck and onblurred
 */
function autoComplete_onclick(cullText, selectCodeStrings){
    if (this.isEnabled) {
        /**
         * Request #95746
         * when user clicks on the icon, the cullText is undefined so we want to bring up the popup
         * window and do the regular stuff. but when the browsers back button is pressed and this
         * method is automatically called, the cullText retains it's old value. and since we don't
         * want to revalidate what's already been validated, we immediatley return.
         */
        if (!this.dirtyFlag && cullText != undefined) {
            return;
        }

        // Set the global verifying flag to true.
        // It is reset back to false when the Autocomplete finishes validation.
        isAutoCompVerifying = true;

        var objectName = this.name + ACPopupNamePostFix;
        //resolveTokens should always comes first because if the tpkens are
        //unresolved it will just exit. Setting the windowIsOpen
        //should be done after this statement.
        if (this.isFieldFilterValidation) {
        	tokens = resolveTokensQuiet(this.tokens,this.form.name);
        } else {
        	tokens = resolveTokens(this.tokens, this.form.name);
        }
        if(tokens == UNRESOLVED){
            // Setting the global autocomp verifying flag
            // to false when tokens are not resolved
            // or else the user will not be able to save
            // the page.
            isAutoCompVerifying = false;
            return;
        }

        // if the autocomplete is doing verification at backend (in IFrame), don't pop up the window!
        if (this.isVerifying) {
            return;
        }

        document[objectName] = this;
        // check if there is request id context
        var undefined;
        var requestIDContext;
        var requestDetailIDContext;
        var taskIDContext;
        var packageIDContext;
        if(this.form.REQUEST_ID_CONTEXT == undefined){
            requestIDContext = "";
        } else {
            requestIDContext = "&REQUEST_ID_CONTEXT="+ this.form.REQUEST_ID_CONTEXT.value;
        }
        if(this.form.REQUEST_DETAIL_ID_CONTEXT == undefined){
            requestDetailIDContext = "";
        } else {
            requestDetailIDContext = "&REQUEST_DETAIL_ID_CONTEXT="+ this.form.REQUEST_DETAIL_ID_CONTEXT.value;
        }
        if (this.form.TASK_ID_CONTEXT == undefined) {
            taskIDContext = "";
        } else {
            taskIDContext = "&TASK_ID_CONTEXT=" + this.form.TASK_ID_CONTEXT.value;
        }
        if (this.form.PACKAGE_ID_CONTEXT == undefined) {
            packageIDContext = "";
        } else {
            packageIDContext = "&PACKAGE_ID_CONTEXT=" + this.form.PACKAGE_ID_CONTEXT.value;
        }
        var cullString = "";
        if(cullText != null){
            cullString = "&CULL_TEXT=" + cl_escape(cullText);
        }
        var currentSelectString = "";
        var visibleValues = decode(this.currentCSValue, true);
        // if the cullText is null, it means user double clicks on the autocomplete icon.
        // if the cullText is equal to the visible values, it means user has not changed the value.
        // if dirtyFlag = false (the text was not changed after validation) then it's ok to keep the previous values
        if (cullText == null || cullText == visibleValues || (this.currentCSValue != undefined && this.dirtyFlag == false)) {
            currentSelectString = "&CURRENT_SELECT_TEXT=" + cl_escape(this.currentCSValue);
        } else {
            if (selectCodeStrings != null && selectCodeStrings != "")
              currentSelectString = "&CURRENT_SELECT_TEXT=" + cl_escape(selectCodeStrings);
            else
              currentSelectString = "&CURRENT_SELECT_TEXT=" + cl_escape(this.blankCodeString);
        }

       // check to see if auto-complete popup window is open
       // if it is, reset it and close out the previous auto-complete
       if (popup != null && popup != undefined && !popup.closed) {
       	 // popup window is open
       	 // now to check if it is an auto-complete window
       	 if (popup.window.closeWindoid != null && popup.window.closeWindoid != undefined) {
      	  	 if (popup.window.name == objectName) {
      	  	   // same field, do not clear out cull text
           	 popup.window.closeWindoid(true);
      	  	 } else {
      	  	 	 // different field, clear out cull text
      	  	 	 popup.window.closeWindoid();
      	  	 }
       	 }
       }

       //The first popup will show the "Loading..." text.
       if (this.isCmdValidation) {
            /*
             * passing in tokenName and visibleTokenName to avoid an infinite recursion
             * that happens when .getValue() method is called on the token stored in pageTokens[][]
             * array.
             */
            resolvePageTokens(this.form.name, this.tokenName, this.visibleTokenName);
       }
       // if we have a defined event, the user clicked the icon, grab the location of the event for the
       // popup location calculation.
       if(window.event) {
         this.tabeventx = window.event.screenX;
         this.tabeventy = window.event.screenY;
       } else {
         if(!this.tabeventx) {
           this.tabeventx = 100;
           this.tabeventy = 100;
         }
       }

       // calculate where on the screen the window should go
       var popupLocation = calculatePopupLocation(autoCompleteWidth,autoCompleteHeight, this.tabeventx, this.tabeventy);
       // Need to pass in Dummy.jsp to avoid javascript error if the page go through navigation path
       // Request#120561
       popup = window.open(BLANK_PAGE,
                            objectName,
                            popupLocation+",toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=no,resizable=yes,copyhistory=no,width=" + autoCompleteWidth + ",height=" + autoCompleteHeight);
       // we need to manually set the cookie in the popup window because IE4 doesn't send it
        var allcookies = document.cookie;
        var pos = allcookies.indexOf("JSESSIONID=");

        // we need to decide whether it is a multi-select or single-select autocomplete
        var isMultiString = "N";
        if(this.isMulti)
            isMultiString = "Y";

        // now we can forward to the AutoCompPopupHandler
        var isDriving = isDrivingField(this.name, this.isDrivingFlag);
        var parameters = requestIDContext +
                         requestDetailIDContext +
                         taskIDContext +
                         packageIDContext +
                         cullString +
                         currentSelectString +
                         "&FIELD_NAME=" + encodeURIComponent(this.name) +
                         "&FIELD_LABEL=" + encodeURIComponent(this.clLabel) +
                         "&IS_WINDOID=Y" +
                         "&IS_MULTI=" + isMultiString +
                         "&KEY=" + getUniqueKey() +
                         "&TOKENS=" + encodeURIComponent(tokens) + // use cl_escape to escape any '+'s in outer joins
                         "&TOKEN_NAMES=" + encodeURIComponent(this.tokens) + // use cl_escape to escape any '+'s in outer joins
                         "&VALIDATION_ID=" + escape(this.validationId) +
                         "&INIT_ACPOPUP=true"+
                         "&OK_TO_PARSE_CUll_STRING=" + this.isMulti +
                         "&HEADER_MESSAGE=" + escape(this.headerMessage) +
                         "&IS_DRIVING_FLAG=" + isDriving +
                         "&IS_BLANKABLE=" + this.isBlankable;

        // other browsers can reload the popup window themselves
        if (encodeServletParams) {
            newLoc = getHostPath() + autoCompPopupServlet + encodeURIComponent(parameters);
        } else {
            newLoc = getHostPath() + autoCompPopupServlet + parameters;
        }
        popup.document.writeln(globalStyleSheet);
        if(newLoc.length > URL_LIMIT){
            // convert to POST
            var actionStr = getHostPath() + autoCompPopupServlet + requestIDContext +
                            requestDetailIDContext + taskIDContext +
                            packageIDContext + cullString;
            var st =  "<html><head><title>IT Governance Autocomplete</title></head>";
            st = st + "<body bgcolor=white onUnload='" + callback +  "'><center><h1><font face=verdana>" + loadingMessage + "</font></h1></center>";
            st = st + "<form name='AC_GET_TO_POST_FRM' method='POST' action='" + actionStr +"'>";

            if (cullText == null || cullText == visibleValues
                || (this.currentCSValue != undefined && this.dirtyFlag == false)) {
                   currentSelectString = this.currentCSValue;
            } else {
                if (selectCodeStrings != null && selectCodeStrings != ""){
                   currentSelectString = selectCodeStrings;
                }else{
                   currentSelectString = this.blankCodeString;
                }
            }
            st = st + "<input type=hidden name='CURRENT_SELECT_TEXT' value='" + escapeForHTML(currentSelectString) + "'>"
            st = st + "<input type=hidden name='FIELD_NAME' value='" + escapeForHTML(this.name) + "'>";
            st = st + "<input type=hidden name='FIELD_LABEL' value='" + escapeForHTML(this.clLabel) + "'>";
            st = st + "<input type=hidden name='IS_WINDOID' value='Y'>";
            st = st + "<input type=hidden name='IS_MULTI' value='" + isMultiString + "'>";
            st = st + "<input type=hidden name='KEY' value='" + getUniqueKey() +  "'>";
            st = st + "<input type=hidden name='TOKENS' value='" + escapeForHTML(tokens) +  "'>";
            st = st + "<input type=hidden name='TOKEN_NAMES' value='" + escapeForHTML(this.tokens) +  "'>";
            st = st + "<input type=hidden name='VALIDATION_ID' value='" + escapeForHTML(this.validationId) + "'>";
            st = st + "<input type=hidden name='INIT_ACPOPUP' value='true'>";
            st = st + "<input type=hidden name='OK_TO_PARSE_CUll_STRING' value='" + this.isMulti + "'>";
            st = st + "<input type=hidden name='HEADER_MESSAGE' value='" + escape(this.headerMessage) + "'>";
            st = st + "<input type=hidden name='IS_DRIVING_FLAG' value='" + isDriving +  "'>";
            st = st + "<input type=hidden name='IS_BLANKABLE' value='" + this.isBlankable + "'>";
            st = st + "</form><script language='Javascript'>document.AC_GET_TO_POST_FRM.submit();</script></body></html>";
            popup.document.writeln(st);
        }else{
            var callback = 'this.window.opener.document["' + objectName + '"].windowIsOpen = false';
            popup.document.writeln("<html><head><title>IT Governance Autocomplete</title><SCRIPT>"+getPopupLocation(newLoc,this)+"</SCRIPT></head><body bgcolor=white onUnload='"
                               + callback + "'><center><h1><font face=verdana>" + loadingMessage + "</font></h1></center></body></html>");
        }
    }
    return;
}


function getPopupLocation(newLoc,element) {
    return "this.document.location=\""+newLoc+"\";\n";
}


/**
 *  This method correctly gets the MSIE or netscaoe browser major version from the
 *  variable navigator.appVersion
 */
function browserMajorVersion(){
    return getBrowserVersion(false);
}
/**
 *  This method correctly gets the MSIE or netscaoe browser minor version from the
 *  variable navigator.appVersion multiplied by 1000
 */
function browserMinorVersion(){
    return parseInt(getBrowserVersion(true)*1000 - getBrowserVersion(false)*1000);
}
/**
 *  Helper function to get the browser version.
 */
function getBrowserVersion(isfloat){
    var index = navigator.appVersion.indexOf("MSIE");
    if(index == -1){
        if(isfloat){
            return parseFloat(navigator.appVersion);
        }else{
            return parseInt(navigator.appVersion);
        }
    }else{
        var lenMSIE = 5;
        var lenVer = 4;
        var version = navigator.appVersion.substring(index+lenMSIE,index+lenMSIE+lenVer);
        if(isfloat){
            return parseFloat(version);
        }else{
            return parseInt(version);
        }
    }
}

/**
 *  getAutoCompWidth returns the desired width for the
 *  autocomplete dialog
 */
function getAutoCompWidth(){
    return autoCompleteWidth;
}
/**
 *  getAutoCompHeight returns the desired Height for the
 *  autocomplete dialog
 */
function getAutoCompHeight(){
    return autoCompleteHeight;
}

function autoComplete_getDrivenFieldsArray () {
    return drivenFieldsArray;
}

/**
 * this function is called only when "Resource Finder" functionality is
 * enabled (server.conf parameter ENABLE_RESOURCE_FINDER)
 */
function autoComplete_rscFind() {
    if(this.isEnabled) {
    var isMultiFlag = "N";

    if (this.isMulti) {
        isMultiFlag = "Y";
    }

    var rowNum = -1;
    var periodType = -1;
    var prefix = "";

    if(this.form.RSC_FINDER_ENTITY_ID.value == 309) {
        var isMultiSP = this.form.IS_MULTI_SP;
        rowNum = this.name.substr(1, 1);
        prefix = "R" + rowNum;

        if(prefix.indexOf("_") != -1 ) {
            var elem = document.getElementById("R_SKILLAC_TFHV");
        } else {
            var elem = document.getElementById(prefix + "_SKILLAC_TFHV");
        }

        var prompt = this.form.SKILL_PROMPT;
        if(elem != null && elem != undefined) {
            if(elem.value == '0.0..' || elem.value == '' || elem.value == null) {
                alert(formatMessage(reqMessage + ' ' + noneSelected, prompt.value));
                return false;
            }
        }
        prefix = "";
        periodType = this.form.ENTRY_PERIOD_TYPE_ID.value;
        if(isMultiSP != null && isMultiSP != undefined && isMultiSP.value == 'Y') {
            prefix = "R" + rowNum;
        }

    }

    openWindoid('../rsc/RscFinder.jsp?IS_MULTI=' + isMultiFlag + '&PARENT_FORM_NAME=' + this.formName +"&PARENT_FIELD_NAME=" + encodeURIComponent(this.name) + "&RSC_FINDER_ENTITY_ID=" + this.form.RSC_FINDER_ENTITY_ID.value + "&RSC_FINDER_PRIMARY_KEY=" + this.form.RSC_FINDER_PRIMARY_KEY.value + "&RSC_FINDER_SKILL_CS=" + encodeURIComponent(eval('this.form.' + prefix + 'RSC_FINDER_SKILL_CS.value')) + "&ROWNUM=" + rowNum + "&PERIOD_TYPE_ID=" + periodType + "&USER_CS=" + encodeURIComponent(this.currentCSValue));
    }
}


/**
 *  Autocomplete javscript object definition.
 */
function AutoComplete(label, element, valueElement, form, required,
                      blankCodeString, currentCSValue, tokenName, visibleTokenName,
                      validationId, tokens, formName, isCmdValidation, isFieldFilterValidation,isMulti,
                      onValueChange, isEnabled, headerMessage, isDrivingFlag, drivenFields, drivenFieldCallback,
                      isUserAutoComplete, isBlankable) {
    this.valuesArray = "";
    this.isDrivingFlag = isDrivingFlag;
    this.drivenFields = drivenFields;
    this.acCallback = drivenFieldCallback;
    this.isUserAutoComplete = isUserAutoComplete;
    this.isBlankable = isBlankable;
    this.clLabel = label;
    this.name = element.name;
    this.element = element;
    this.valueElement = valueElement;
    this.form = form;
    //Requires a loop back from html component to this object
    //Usage is for the popup window.
    this.required = required;
    this.emptyString = blankCodeString;
    this.blankCodeString = blankCodeString;
    this.defaultClass = this.element.className; // useful for switching back from disabled
    this.disabledClass = 'textareadisabled'; // should be passed in as a param in the future
    this.element.onchange = autoComplete_onchange;
    this.element.onblur = onblurred;
    this.element.onfocus = onfocussed;
    // Since the hidden field associated with this autocomplete takes
    // precedence, we want to always use its value for the CS upon construction
        if(this.valueElement == undef) {
            this.currentCSValue = currentCSValue;
        }
        else {
            this.currentCSValue = this.valueElement.value;
        }

    this.element.value = decode(this.currentCSValue, true);
    this.element.alt = "click me";
    this.formName = formName;
    if(tokenName != ""){
        new Token(tokenName, this, false, formName);
    }
    if(visibleTokenName != ""){
        new Token(visibleTokenName, this, true, formName);
    }
    this.validationId = validationId;
    this.tokens = tokens;

    // the isCmdValidation flag specifies whether it's a command validation or not
    this.isCmdValidation = isCmdValidation;

    //the isFieldFilterValidation specifies whether it's a field filter validation.
    //If so then it will set unresolved tokens to ''
    this.isFieldFilterValidation = isFieldFilterValidation;

    // the isMulti flag specifies whether it is a multi-select or not
    this.isMulti = isMulti;
    this.dirtyFlag = false;
    this.windowIsOpen = false;
    this.onValueChange = onValueChange;
    this.RuleArray = new Array();
    this.isEnabled = isEnabled;
    // If the autocomplete needs to do a call back to the ruleutil when the window closes.
    this.ruleCallBackOnClose = false;

    // this flag indicates whether the autocomplete is doing validation in IFrame
    this.isVerifying = false;

    // the autocompleteName specifies the name of the image, used when enabling/disabling
    this.autocompleteName = this.name+"AUTOCOMP_IMG";
    this.rscFindImg = this.name+"RESOURCE_FINDER_IMG";
    this.headerMessage = headerMessage;
    if(!hashParentChildPageTokens &&
       formName!=undef &&
       formName!="" &&
       formName.indexOf("TEF")!=-1)//TEF is table entry form prefix.
    {
    //This if statement is used for token handling in the table entry form
    //sometimes we need to hash the parent tokens to the child tokens inorder to do some
    //token resolution in the child table entry windoids if needed.
        if(isCmdValidation || tokens.indexOf("[REQ") != -1){
            //if it's a command validation in a table component or
            //tokens in the table component starts with "[REQ"
            hashParentChildPageTokens = true;
        }
    }
}

new AutoComplete("", "", "", "", false, "" ,"", "", "", "", "", "", false,false, "", false, "");
AutoComplete.prototype.validate      = _validateAutoComplete;
AutoComplete.prototype.getTokenValue = autoComplete_getTokenValue;
AutoComplete.prototype.setValue      = autoComplete_setValue;
AutoComplete.prototype.getValue      = autoComplete_getValue;
AutoComplete.prototype.getValueForRule = autoComplete_getValue;
AutoComplete.prototype.setRequired   = generic_setRequired;
AutoComplete.prototype.isCodeString  = yes_codestring;
AutoComplete.prototype.resetValue    = autoComplete_resetValue;
AutoComplete.prototype.onclick       = autoComplete_onclick;
AutoComplete.prototype.onclickCheck  = autoComplete_onclickCheck;
AutoComplete.prototype.preVerify     = autoComplete_preVerify;
AutoComplete.prototype.getLabel      = getLabel;
AutoComplete.prototype.resetDefaults = autoComplete_resetDefaults;
AutoComplete.prototype.getDrivenFieldsArray = autoComplete_getDrivenFieldsArray;
AutoComplete.prototype.addListener   = rules_addListener;
AutoComplete.prototype.setEnabled    = autoComplete_setEnabled;
AutoComplete.prototype.isNotEmpty    = rules_isNotEmpty;
AutoComplete.prototype.chkValue      = rules_chkValue;
AutoComplete.prototype.rscFind       = autoComplete_rscFind;

// preload autocomplete enabled and disabled images
autocompleteImg = new Image();
autocompleteImg.src = autoCompImgSrc;
userAutocompleteImg = new Image();
userAutocompleteImg.src = userAutoCompImgSrc;
autocompleteDisabledImg = new Image();
autocompleteDisabledImg.src = autoCompDisabledImgSrc;
userAutocompleteDisabledImg = new Image();
userAutocompleteDisabledImg.src = userAutoCompDisabledImgSrc;
rscFindImg = new Image();
rscFindImg.src = rscFindImgSrc;
rscFindDisabledImg = new Image();
rscFindDisabledImg.src = rscFindDisabledImgSrc;

/**
 *  END AUTOCOMPLETE OBJECT
 */

/**
 *  BEGIN TEXTAREA OBJECT
 */
function _validateTextArea(forceCheck) {
    this.element.value = trimString(this.element.value);
    trimAlert(this.maxSize, this.clLabel, this.element);


    //error if numeric and not a number
   if(this.isNumeric) {
        var numstr = this.element.value;
        var num = getNumberString(numstr, this.clLabel);
        if(!num ) {
           return true;
        }
        if (num == NUM_NO_GROUP_SEP)
        {
            if(showAlert) {
                alert(formatMessage(containsGroupSeparator, this.clLabel));
            }
            return false;
        }
        if((num == NUM_NON_FORMAT_CHARS || num == NUM_FORMAT_CHARS_INTERCHANGED) &&
            this.decimalPlaces == 0) {
            if(showAlert) {
                alert(formatMessage(noDecimalNumberMessage, this.clLabel));
            }
            return false;
        }
        if(num == NUM_NON_FORMAT_CHARS) {
           if(showAlert) {
            alert(formatMessage(unrecognizedChar, this.cllabel));
           }
           return false;
        }
        if(num == NUM_FORMAT_CHARS_INTERCHANGED) {
            if(showAlert) {
                alert(formatMessage(formatCharsInterchanged, this.label));
            }
            return false;
        }
        if(isNaN(num) == true) {
            if(showAlert) {
                alert(formatMessage(numericInvalidCharsMessage, this.clLabel));
            }
            return false;
        }
        if (this.decimalPlaces == 0) {
            // this vlaue should not be a decimal number
            //if (this.element.value.indexOf('.') > -1) {
            if (num.indexOf('.') > -1) {
                if(showAlert) {
                    alert(formatMessage(noDecimalNumberMessage, this.clLabel));
                }
                return false;
            }
        }
        else {
            var index = this.element.value.indexOf(userDecimalSep);
            // if there is a decimal point then validate the no of decimal digits
            if (index > -1) {
                var numDecimalDigits = this.element.value.length - 1 - index;
                if (numDecimalDigits > this.decimalPlaces) {
                    if(showAlert) {
                        alert(formatMessage(decimalDigitsExceededMessage, this.clLabel, this.decimalPlaces));
                    }
                    return false;
                }
                else if (numDecimalDigits == 0) {
                    // remove the trailing decimal point
                    this.element.value = this.element.value.substring(0, index);
                }
            }
        }
    }



    //error if required and trimmed value matches empty value
    if(checkRequired && (this.required==true || (forceCheck != null && forceCheck)) &&
       (this.element.value==this.emptyString)) {
        requiredAlert(this.clLabel);

        return false;
    }
    return true;
}

/**
 *   If the datamask is numeric the field could have formatted input.
 *   Convert to format - '.' as the decimal separator, No group separator
 */
 function textArea_getTokenValue(isVisible) {
     if(!this.isNumeric) {
         if(this.validate(true)) {
             return decode(this.element.value, isVisible);
         }else {
             return "";
         }
     }else {
         if(this.validate(true)) {
             return getNumberString(trimString(this.element.value));
         }else {
             return "";
         }
     }
}

/**
 *  TextArea javascript object definition
 */
function TextArea(label, element, required, emptyString, maxSize, tokenName, visibleTokenName, isNumeric, decimalPlaces, numberFormattable, form) {
    this.clLabel = label;
    this.name = element.name;
    this.element = element;
    this.required = required;
    this.emptyString = emptyString;
    this.maxSize = maxSize;
    this.isNumeric = isNumeric;
    this.decimalPlaces = decimalPlaces;
    this.numberFormattable = numberFormattable;
    this.focusable = true;
    this.RuleArray = new Array();
    if(tokenName != ""){
        new Token(tokenName, this, false, form);
    }
    if(visibleTokenName != ""){
        new Token(visibleTokenName, this, true, form);
    }
}

new TextArea("", "", false, "", "", "", "");
TextArea.prototype.addListener = rules_addListener;
TextArea.prototype.validate = _validateTextArea;
TextArea.prototype.getTokenValue = textArea_getTokenValue;
TextArea.prototype.getLabel = getLabel;
TextArea.prototype.setEnabled = textField_setEnabled;
TextArea.prototype.setValue = textarea_setValue;
TextArea.prototype.setTextValue = textField_setValue;
TextArea.prototype.getValue = textfield_getValue;
TextArea.prototype.getValueForRule = textfield_getValue;
TextArea.prototype.isCodeString = no_codestring;
TextArea.prototype.setRequired = generic_setRequired;
TextArea.prototype.text_fmtValue = textField_fmtValue;

/**
 *  END TEXTAREA OBJECT
 */

/**
 *  BEGIN DATEFIELD OBJECT
 *  We use integers to define the dateStyle and timeStyle for the Date fields.
 *  The mapping of styles are as follows
 *  LONG = DBConstants.DATE_FORMAT_LONG = 1.
 *  MEDIUM = DBConstants.DATE_FORMAT_MEDIUM = 2.
 *  SHORT = DBConstants.DATE_FORMAT_SHORT = 3.
 */

/**
 *  Prepends a zero "0" if the number of digits is just
 *  1 this is mimic the database representation of timestamp
 */
function prependZero(nNumber){
    nNumber-=0; // Make sure nNumber is a number and not a string.
    if(nNumber < 10){
        return "0" + nNumber.toString();
    } else{
        return nNumber.toString();
    }
}

/**
 * Removes preceding zero from month or date values
 */
 function removePrecedingZero(nNumber) {

 }


/**
 * Constructs a list of valid date entries for display
 * along with error message when date input is invalid
 */
function constructValidDates() {
    var validDates = "\n\n";
    var d = new Date();
    for(var i = 0; i < userDateFormats.length; i++) {
        validDates += formatDate(d, userDateFormats[i], i) + "\n";
    }
    for(var i = 0; i < partialDateFormats.length; i++) {
        validDates += formatDate(d, partialDateFormats[i], 1) + "\n";
    }
    return validDates;
}

/**
 * Constructs a list of valid time entries for display
 * along with error message when time input is invalid
 */
function constructValidTimes() {
    var validTimes = "\n\n";
    var d = new Date();
    // validTimes += formatTime(d, userTimeFormat, i) + "\n";
    for(var i = 0; i < supportedTimeFormats.length; i++) {
        validTimes += formatTime(d, supportedTimeFormats[i], 1) + "\n";
    }

    // time zone examples
    validTimes += formatTime(d, "h:mm:ss a", 1);
    validTimes += " BDT\n";

    validTimes += formatTime(d, "h:mm a", 1);
    validTimes += " GMT+2:00\n";

    validTimes += formatTime(d, "H:mm", 1);
    validTimes += " GMT-4:23\n";

    return validTimes;
}

/**
 * Formats a date object according to the format supplied
 * Replaces the date separator char depending on the value of the dateStyle
 */
function formatDate(date, format, dateStyle, isBlankable, keepDefaultSep) {
    if (isBlankable && date == BLANK_FIELD_TEXT) {
      return BLANK_FIELD_TEXT;
    }
    var formattedDate = format;
    var day = date.getDate();
    var month = date.getMonth();
    var year = date.getFullYear();
    if (isNaN(day) || isNaN(month) || isNaN(year)) {
      return null;
    }
    formattedDate = formattedDate.replace(/2D/i, prependZero(day));
    formattedDate = formattedDate.replace(/1D/i, day);
    formattedDate = formattedDate.replace(/4Y/i, year);
    formattedDate = formattedDate.replace(/2Y/i, prependZero((year%100)));
    formattedDate = formattedDate.replace(/4M/i, MonthsArray[month][0]);
    formattedDate = formattedDate.replace(/3M/i, MonthsArray[month][1]);
    formattedDate = formattedDate.replace(/2M/i, prependZero(month+1));
    formattedDate = formattedDate.replace(/1M/i, month+1);
    //replace the date separator char only if dateStyle is medium or short
    if(!keepDefaultSep && (dateStyle == 2) || (dateStyle == 3)) {
        var re = new RegExp(dateSep, "gi");
        formattedDate = formattedDate.replace(re, userDateSep);
    }
    return formattedDate;
}

/**
 * Formats a time object according to the format supplied
 * Removes the seconds depending on the value of the timeStyle
 */
function formatTime(time, userTimeFormat, timeStyle, timeZone, isBlankable) {
    if (isBlankable && time == BLANK_FIELD_TEXT) {
      return BLANK_FIELD_TEXT;
    }
    var formattedTime = userTimeFormat;
    var hour = time.getHours();
    var min = time.getMinutes();
    var sec = time.getSeconds();
    if (isNaN(hour) || isNaN(min) || isNaN(sec)) {
      return null;
    }
    formattedTime = formattedTime.replace(/mm/i, prependZero(min));
    if(timeStyle < 3){
        formattedTime = formattedTime.replace(/ss/i, prependZero(sec));
    }
    else {
        //remove the seconds value from display
        formattedTime = formattedTime.replace(/[:\\.]ss/i, "");
    }
    if( !timeZone ) {
        formattedTime = formattedTime.replace(/z/i, tzString);
    }
    else {
        formattedTime = formattedTime.replace(/z/i, timeZone);
    }
    var ampmString = userAMSymbol;
    if(((userTimeFormat.indexOf("hh") != -1) ||(userTimeFormat.indexOf("h") != -1)) ) {
        if( hour >= 12 ) {
            ampmString = userPMSymbol;
            if( hour > 12 ){
                hour = hour - 12;
            }
        } else if( hour == 0 ) {
            hour = 12;
        }
    }
    if(((userTimeFormat.indexOf("HH") != -1) || (userTimeFormat.indexOf("H") != -1)) && hour > 12) {
        ampmString = userPMSymbol;
    }
    formattedTime = formattedTime.replace(/HH/, prependZero(hour));
    formattedTime = formattedTime.replace(/H/, hour);
    formattedTime = formattedTime.replace(/hh/, prependZero(hour));
    formattedTime = formattedTime.replace(/h/, hour);
    formattedTime = formattedTime.replace(/a/i, ampmString);
    //replace the separator char with the users time separator char
    var re = new RegExp(timeSep, "gi");
    formattedTime = formattedTime.replace(re, userTimeSep);
    return formattedTime;
}

/**
 * Formats the date and time values in the date according to the formats supplied
 */
function formatDateTime(dateTime, dateFormat, timeFormat, dateStyle, timeStyle, timeZone, isBlankable) {
    if (isBlankable && dateTime == BLANK_FIELD_TEXT) {
      return BLANK_FIELD_TEXT;
    }
    var formattedDate = formatDate(dateTime, dateFormat, dateStyle);
    if (formattedDate == null) {
      return null;
    }
    var formattedTime = formatTime(dateTime, timeFormat, timeStyle, timeZone);
    if (formattedTime == null) {
      return null;
    }
    return formattedDate + " " + formattedTime;
}

/**
 * Constructs a string in the "yyyy-mm-dd hh:mm:ss.fffffffff" format
 * from the date value
 */
function buildDateTokenValue(date, isBlankable) {
    if (isBlankable && date == BLANK_FIELD_TEXT) {
      return BLANK_FIELD_TEXT;
    }
    return date.getFullYear()              + "-" +
           prependZero(date.getMonth()+1)  + "-" +
           prependZero(date.getDate())     + " " +
           prependZero(date.getHours())    + ":" +
           prependZero(date.getMinutes())  + ":" +
           prependZero(date.getSeconds())  + ".0";
}

/**
 * Checks if the year, month and day values
 * will construct a valid date
 */
function checkYMD(year, month, day) {
    var dateObj = new Date(year, month-1, day);
    if(year == dateObj.getFullYear()
       && month == dateObj.getMonth()+1
       && day == dateObj.getDate()){
       return true;
    }
    return false;
}

/**
 * Just returns true for now. Might change later
 */
function checkTime(hour,min, sec, ampm, timeZone) {
    return true;
}

/**
 * If any of the year month and day values are missing they
 * are replaced with the current values of year, month or date
 */
function convertDate(year, month, day) {
    if(!year){
        year = new Date().getFullYear();
    }
    else {
        year = year - 0;
        if(year < pivotYear) {
            year += 2000;
        }
        if(year < 100 && year > (pivotYear - 1)) {
            year += 1900;
        }
    }
    if(!month) {
        month = new Date().getMonth() + 1;
    }
    else {
        if(isNaN(month)) {
        //if month is entered with non-digit chars ( ex. September or Sep)
        // it is replaced with the correct value for month from the names
        //array that is printed to the page from the FormatsWriter for this user
            month = MonthHash[month.toLowerCase()];
        }
    }
    if(!day) {
        day = new Date().getDate();
    }
    return [year, month, day];
}

/**
 * Variables required for time conversion
 */
var dayInMillis   = new Number(24 * 60 * 60 * 1000);
var hourInMillis  = new Number(60 * 60 * 1000);
var minInMillis   = new Number(60 * 1000);
var secInMillis   = new Number(1000);

/**
 * Converts the time. If any values are missing they are replaced with 0.
 * If the timezone entry is different form the servertimezone, then the
 * time value is converted to the server time zone
 */
function convertTime(hour, min, sec, ampm, inputTimeZone) {
    var h, m , s;
    var ms = new Number(0);
    var a, z, dayChange;

    if(!hour) {
        h = new Number(0);
    }
    else {
        h =  new Number(hour);
    }
    if(!min){
        m = new Number(0);
    }
    else {
        m = new Number(min);
    }
    if(!sec){
        s = new Number(0);
    }
    else {
        s = new Number(sec);
    }
    if(!ampm){
        a = "";
    }
    else {
        // converting from 12 to 24 hr format
        var pRE = new RegExp(pmSymbols, "i");
        if( pRE.test(ampm) ) {
            if( h < 12 ) {  // do not convert 12 PM
                var h1 = new Number(h)
                h =  h1 + 12;
                a = userPMSymbol;
            }
        }
        else {
            a = userAMSymbol;
            if( h == 12 ) { // convert 12 AM to 0
                h = new Number(0);
            }
        }
    }
    if(!inputTimeZone){
        z = tzString;
    }
    else {
        z = inputTimeZone;
    }
    return [h, m, s, ms, a, z, dayChange];
}

/**
 * Converts the date and time adjusting for the changes between the days, months
 * and years when the time is converted between timezones
 */
function convertDateTime(year, month, day, hour, min, sec, ampm, tz) {
    var date = convertDate(year, month, day);
    var time = convertTime(hour, min, sec, ampm, tz);
    var day = date[2];
    var dayChange = time[6];
    if(checkYMD(date[0], date[1], date[2])) {
        if(!dayChange){
            return [date[0],date[1], date[2], time[0], time[1], time[2],time[3], time[4], time[5]];
        }
        else {
            day = new Number(day);
            day += dayChange;
            if(checkYMD(date[0], date[1], day)) {
                return [date[0], date[1], day, time[0], time[1], time[2],time[3], time[4], time[5]];
            }
            else {
                var nDate = new Date(date[0], date[1] - 1, day);
                var y = nDate.getFullYear();
                var m = nDate.getMonth() + 1;
                var d = nDate.getDate();
                return [y, m, d, time[0], time[1], time[2],time[3], time[4], time[5]];
            }
        }
    }
    else {
        showInvalidDateTimeMessage(this.clLabel);
        return "";
    }

}

/**
 * Build a hash from the months array that is written to the page
 * from the FormatsWriter
 */
function buildMonthsHash() {
    var MonthHash = new Array();
    for( i = 0; i < MonthsArray.length; i++) {
        MonthHash[MonthsArray[i][0].toLowerCase()] = i+1;
        MonthHash[MonthsArray[i][1].toLowerCase()] = i+1;
    }
    return MonthHash;
}

/*
 * Variable to determine the value of full year if two digit year (YY) is entered.
 * If YY < 50, then year = 20YY. If YY >= 50, year = 19YY.
 */
var pivotYear = 50;

/**
 * Declared and global so these variables are constructed onlne for all the DateField
 * objects on the page and for repeated refernces within a single dateField object.
 */
var MonthHash;
var DateFormats;
var TimeFormats;
var dateFormatsRE;
var timeFormatsRE;
var dateTimeFormatsRE;
var validDates ;
var validTimes ;

/**
 * Constructs complete strings for use in creating RegExp objects for validating the
 * date input. Also builds an array containing the sequence of date, month, year and
 * date separator fields in this format.
 */
function buildDateFormats(){
    var DateFormats = new Array();
    for(var i = 0; i < allDateFormats.length; i++){
        var re = "";
        var dateFieldSeq;
        var seq = allDateFormats[i];
        var seqArr = new Array();

        for( var j = 0; j < seq.length; j++) {
           if(seq[j] == "day"){
               re += day ;
               seqArr[j] = "day";
           }
           if(seq[j] == "month"){
               re += month ;
               seqArr[j] = "month";
           }
           if(seq[j] == "year"){
               re += year ;
               seqArr[j] = "year";
           }
           if(seq[j] == "dateSep")
               re += dateSep ;
        }
        re += optionalDateSep;
      DateFormats[i] = [re, seqArr];
   }
   return DateFormats;
}

/**
 * Constructs complete strings for use in creating RegExp objects for validating the
 * time input. Also builds an array containing the sequence of hour, minute, sec and
 * time separator fields in this format.
 */
function buildTimeFormats() {
    var TimeFormats = new Array();
    for(var i = 0; i < allTimeFormats.length; i++) {
        var re = "";
        var seq = allTimeFormats[i];
        var seqArr = new Array();
        for( var j = 0; j < seq.length; j++) {
           if(seq[j] == "hour"){
               re += hour ;
               seqArr[j] = "hour";
           }
           if(seq[j] == "min") {
               re += min ;
               seqArr[j] = "min";
           }
           if(seq[j] == "sec") {
               re += sec ;
               seqArr[j] = "sec";
           }
           if(seq[j] == "timeSep")
               re += timeSep;

           if(seq[j] == "ampm"){
               re += space + ampmSymbols ;
               seqArr[j] = "ampm";
           }
           if(seq[j] == "timeZone"){
               if(!timeZone){
                   timeZone = buildTimeZoneRE();
               }
               re += space + timeZone ;
               seqArr[j] = "timeZone";
           }
        }
        TimeFormats[i] = [re, seqArr];
    }
    return TimeFormats;
}

/**
 * An object that will hold the sequences of the fields as they
 * occurred when an input is validated
 */
function DateTimeFieldSeq(yearFS, monthFS, dayFS, hourFS, minFS, secFS, ampmFS, timeZoneFS) {
    this.yearFS = yearFS;
    this.monthFS = monthFS;
    this.dayFS = dayFS;
    this.hourFS = hourFS;
    this.minFS = minFS;
    this.secFS = secFS;
    this.ampmFS = ampmFS;
    this.timeZoneFS = timeZoneFS;
}

/**
 * Constructs the DateTimeFieldSeq object from the date and time sequence
 * arrays that are passed in
 */
function getFieldSeq(dSeq, tSeq) {
    var seq = new Array();
    var retSeq = new DateTimeFieldSeq();
    var count=0;
    if(dSeq) {
        for(var i = 0; i < dSeq.length; i++) {
            seq[i] = dSeq[i];
            count++;
        }
    }
    if(tSeq){
        for( var i = 0; i < tSeq.length; i++) {
            seq[count] = tSeq[i];
            count++;
        }
    }

    var j = 1;
    for(var i = 0; i < seq.length; i++) {
        if(!seq[i])
            continue;
        if(seq[i] == "day"){
            retSeq.dayFS = j;
        }
        if(seq[i] == "month"){
            retSeq.monthFS = j;
        }
        if(seq[i] == "year"){
            retSeq.yearFS = j;
        }
        if(seq[i] == "hour"){
            retSeq.hourFS = j;
        }
        if(seq[i] == "min"){
            retSeq.minFS = j;
        }
        if(seq[i] == "sec"){
            retSeq.secFS = j;
        }
        if(seq[i] == "ampm"){
            retSeq.ampmFS = j;
        }
        if(seq[i] == "timeZone"){
            retSeq.timeZoneFS = j;
        }
        j++;
    }
    return retSeq;
}

/**
 * Constructs the necessary strings for creation of RegExp objects based on the
 * datePresent and timePresent values.
 */
function buildFormatRE(dateFormats, timeFormats, datePresent, timePresent) {

    if(datePresent && !timePresent) {
        if(!dateFormatsRE) {
            dateFormatsRE = new Array();
            for(  var i = 0; i < dateFormats.length; i++) {

                dateFormatsRE[i] = ["^" + dateFormats[i][0]+"$", getFieldSeq(dateFormats[i][1])];
            }
            return dateFormatsRE;
        }
        return dateFormatsRE;
    }
    if(!datePresent && timePresent) {
        if(!timeFormatsRE) {
            timeFormatsRE = new Array();
            for(  var i =0; i < timeFormats.length; i++) {
                timeFormatsRE[i] = ["^" + timeFormats[i][0] + "$", getFieldSeq(timeFormats[i][1])];
            }
            return timeFormatsRE;
        }
        return timeFormatsRE
    }
    if((datePresent && timePresent) ) {
        if(!dateTimeFormatsRE) {
            dateTimeFormatsRE = new Array();
            var k = 0;
            for(  var i =0; i < dateFormats.length; i++) {
                for(var j = 0; j < timeFormats.length; j++) {
                    dateTimeFormatsRE[k] = ["^" + dateFormats[i][0] + spaceMust + timeFormats[j][0] +"$",
                                 getFieldSeq(dateFormats[i][1],timeFormats[j][1])] ;
                    k++;
                }
            }
            return dateTimeFormatsRE;
        }
        return dateTimeFormatsRE;
    }

}

/**
 * Constructs the necessary strings for creation of RegExp objects based on the
 * all possible combinations of datePresent and timePresent values. This is used
 * in case the dateStyle and timeStyle values for the DateField object are not
 * equal to 1, 2, or 3.
 */
function buildAllFormatsRE() {
    var allFormatRE = new Array();
    var k = 0;
    var dtRE = buildFormatRE(DateFormats, TimeFormats, true, true);
    for(var i = 0; i < dtRE.length; i++ ) {
        allFormatRE[k] = [dtRE[i][0], dtRE[i][1]] ;
        k++;
    }
    var dRE = buildFormatRE(DateFormats, TimeFormats, true, false);
    for(var i = 0; i < dRE.length; i++ ) {
        allFormatRE[k] = [dRE[i][0], dRE[i][1]];
        k++;
    }
    var tRE = buildFormatRE(DateFormats, TimeFormats, false, true);
    for(var i = 0; i < tRE.length; i++ ) {
        allFormatRE[k] = [tRE[i][0], tRE[i][1]];
        k++;
    }
    return allFormatRE;
}

/**
 * Determines if the components ((date or time) or (date and time))
 * are present in this DateField object
 */
function getDateTimePresent(dateStyle, timeStyle) {
    datePresent = false;
    timePresent = false;

    if((dateStyle > 0 && dateStyle < 4) && (timeStyle <= 0 || timeStyle >= 4)) {
        datePresent = true;
        timePresent = false;
    }
    if((dateStyle <= 0 || dateStyle >= 4) && (timeStyle > 0 && timeStyle < 4)) {
        datePresent = false;
        timePresent = true;
    }
    if((dateStyle > 0 && dateStyle < 4) && (timeStyle > 0 && timeStyle < 4)) {
        datePresent = true;
        timePresent = true;
    }
    return [datePresent, timePresent];
}

/**
 *  returns true if the selected values are valid
 */
function _validateDateField(forceCheck) {

   //alert( '_validateDateField for ' + this.clLabel + ' says validateOnServer: ' + this.validatedOnServer);
   //required field needs day, month, and year all filled in
   if(checkRequired && (this.required || (forceCheck != null && forceCheck)) ) {
        if(this.element.value == '' || this.element.value == null) {
            requiredAlert(this.clLabel);
            return false;
       }
   }
   if((!this.required) && (this.element.value == "")) {
       return true;
   }

   // if the validation is still being done (since onchange event might still
   // be running to validate the field against the server), wait for it to
   // get done.
   var validatingOnServer = eval('window.' + this.formName + '.' + this.name + '.validatingOnServer');
   if( validatingOnServer ) {
       waitForServerReturn('document.'+this.formName+'.'+this.name, '');
   }

   //if input has been validated on Server (done field has time component in it) return true.
   if(this.validatedOnServer) {
       return true;
   } else {
       if( !validatingOnServer ) {
           if( this.errorCall != null ) {
               eval(this.errorCall);
           } else {
               // this should not happen
               showMissingErrorMessage(this.clLabel);
           }
       }
       return false;
   }
}

/**
 * Pops an error message when validatedOnServer is false, but no error is generated
 */
function showMissingErrorMessage(label){
    alert(formatMessage(missingErrorOnDateError, label));
}

/**
 * Pops an error message and the valid date inputs
 */
function showInvalidDateMessage(label){
    if(!validDates) {
           validDates = constructValidDates();
        }
    alert(formatMessage(invalidDate, label, validDates));
    resumeOnclickEvents();
}

/**
 * Pops an error message and the valid time inputs
 */
function showInvalidTimeMessage(label){
    if(!validTimes) {
            validTimes = constructValidTimes();
        }
    alert(formatMessage(invalidTime, label, validTimes));
    resumeOnclickEvents();
}

/**
 * Pops an error message and the valid date and time inputs
 */
function showInvalidDateTimeMessage(label){
    if(!validDates) {
            validDates = constructValidDates();
    }
    if(!validTimes) {
        validTimes = constructValidTimes();
    }
    alert(formatMessage(invalidDateOrTime, label, validDates, validTimes));
    resumeOnclickEvents();
}

/**
 * Pops an error message about an invalid entry for date/time value
 */
function showInvalidDateTimeValueMessage(label){
    alert(formatMessage(invalidDateValue, label));
    resumeOnclickEvents();
}

/**
 *  The token format is "yyyy-mm-dd hh:mm:ss"
 *  Note that tokenValue only contains one value (ie. it is not a code/meaning pair)
 *  This is due to provide consistency on the back-end (visible value is what the
 *  user see.. in most other cases it is also stored on the database, but it does NOT
 *  make sense to store the visible value in the database since for dates, visible value vary
 *  depending on the user.  Hence by making the visible the same as the hidden,
 *  we consistenly DO NOT STORE formatted date).
 *  If the token is NOT specified to be visible or non-visible, then isVisible is false
 *  by default.
 *  If the token requires a visible value, we return the text currently displayed
 *  by the object.
 */
function dateField_getTokenValue(isVisible){
    if (this.element && !(this.isBlankable && trimString(this.element.value) == BLANK_FIELD_TEXT)) {
        if( isVisible == null || !isVisible ) {
            if(trimString(this.element.value) != "" && this.validate()){
                return this.tokenValue;
            }
        } else {
            if(trimString(this.element.value) != "" && this.validate()){
                return this.element.value;
            }
        }
    }
    return "";
}

/**
 * The following variable is used in the Search page. When user hit
 * "Enter/Return" key, it needs to first validate the date field
 * before any Search happens.
 */
function dateFieldOnFocus() {
    focussedDate = findJSOForElement(this);
}

/**
 * It needs to clear out the last focus date field when an onblur
 * event happens.
 */
function dateFieldOnBlur() {
    var undefined;
    focussedDate = undefined;
}

/**
 * When the DateField content changes
 */
function dateFieldOnChange(){
    //validate on the server
    var obj = findJSOForElement(this);

    // whenever the user has null'ed out the value of the date field,
    // then we should update our cached value as undefined.
    // this way, next time the date value has changed, then the rule will be invoked
    // for this date field.
    if( obj.value == null || obj.value == '' ) {
        obj.cachedValue = undef;
    }

    obj.setValueElement("");
    obj.validatedOnServer = false;

    if (obj.isBlankable && trimString(this.value).toUpperCase() == BLANK_FIELD_TEXT.toUpperCase()) {
        obj.validatedOnServer = true;
        obj.setValueElement(BLANK_FIELD_TEXT);
        obj.setValue(BLANK_FIELD_TEXT);
        if (obj.pairName != "") {
            var pairObj = findJSOForElement(document.forms[obj.formName].elements[obj.pairName]);
            pairObj.setValue("");
            pairObj.setValueElement("");
            pairObj.setEnabled(false);
        }
    } else {
        if (obj.isBlankable) {
            // this field is a blankable field, so check if it has
            // a corresponding "to" field that should be re-enabled
            if (obj.pairName != "") {
                var pairObj = findJSOForElement(document.forms[obj.formName].elements[obj.pairName]);
                pairObj.setEnabled(true);
            }
        }
        if (trimString(this.value) != "") {
            suspendOnclickEvents();
            obj.formatDateOnServer(this.value, false, obj.isBlankable);
        } else {
    	       // empty date, no need to validate
        	   obj.validatedOnServer = true;
        }
    }
    // Only block on the server returning if we have a custom on change event
    // to execute for this field.
    if (obj.defaultOnChange != null) {
        waitForServerReturn('document.'+obj.formName+'.'+obj.name,
            'window.'+obj.formName+'.'+obj.name+'.defaultOnChange()');
    }

    waitForServerReturn('document.'+obj.formName+'.'+obj.name,
        'window.'+obj.formName+'.'+obj.name+'.ruleChange()');
}

/**
 * This method will execute code only after the server returns from validation,
 * and only if the input to the date field is valid.  This is because we use
 * a jsp in a hidden frame to validate the input on the server, and the javascript
 * is unable to wait for it to return.  This method will check whether the
 * server validation is complete once ever 100ms.
 *
 * The field and the code to execute passed in must be string references to
 * the date object and method, just as if you were putting them into html
 * as javascript: parameters.
 *
 * variable "executeAlways" if set to true, will ALWAYS execute the "codeToExecute"
 * after a server finishes validating, no matter if the validation was successful.
 */
function waitForServerReturn(dateField, codeToExecute, executeAlways) {
    var obj = findJSOForElement(eval(dateField));

    if (obj.validatingOnServer) {
        // If still validating on the server, check again in 1/10 second.
        setTimeout('waitForServerReturn(\''+dateField+'\',\''+codeToExecute+'\')', 100);
    } else {
        // The server validation is done.  If the validation was successful
        // execute the method given, otherwise stop without executing.
        if (obj.validatedOnServer || (executeAlways != undefined && executeAlways)) {
            eval(codeToExecute);
        }
    }
}

function dateField_ruleChange() {
    if(this.RuleArray.length > 0) {
        if( this.cachedValue == undef && this.element.value != null) {
            RuleUtil.evaluateRules(this.RuleArray, this.getValue(), this.isCodeString());
            this.cachedValue = this.element.value;
        } else if( this.cachedValue != this.element.value ) {
            RuleUtil.evaluateRules(this.RuleArray, this.getValue(), this.isCodeString());
            this.cachedValue = this.element.value;
        }
    } else {
        RuleUtil.isPendingFlag = false;
        resumeOnclickEvents();
    }
}

function dateField_callBack() {
    if (this.defaultOnChange != null) {
          this.defaultOnChange();
    }
    resumeOnclickEvents();
}

function dateField_setValue(timestamp,noCascade) {
    timestamp = decode(timestamp);
    timestamp = timestamp.substring(0,19); // remove millie second.
    this.tokenValue = timestamp;
    this.setValueElement(this.tokenValue);
    this.element.value = this.date_fmtValue(timestamp);
    if( noCascade == undef || noCascade ) { // i.e. a Rule has set this value
        this.element.cachedValue = this.element.value;
        this.validatedOnServer = true;
    }
}

/**
 * Sets the value for the DateField objects element
 */
function dateField_fmtValue(timestamp) {
    if(timestamp.length == 0) {
        return "";
    } else if (this.isBlankable && timestamp == BLANK_FIELD_TEXT) {
      return BLANK_FIELD_TEXT;
    } else {
        //format the display on server if server's time zone uses daylight savings time
        //and this date field has time component in it.
        if((serverTZUsesDST == true) && (this.timeStyle > 0 && this.timeStyle < 4)){
            this.formatDateOnServer(timestamp, true, this.isBlankable);
        }else {
            var year, month, date, hour, min, sec, msec;
            year = timestamp.substring(0,4);
            month = timestamp.substring(5,7);
            date = timestamp.substring(8,10);
            hour = timestamp.substring(11,13);
            min = timestamp.substring(14,16);
            sec = timestamp.substring(17,19);
            msec = timestamp.substring(20);
            var date = new Date(year, month-1, date, hour, min, sec, msec);

            var dateTimePresent = getDateTimePresent(this.dateStyle, this.timeStyle);
            var datePresent = dateTimePresent[0];
            var timePresent = dateTimePresent[1];
            if(datePresent && !timePresent){
                var tempDate = formatDate(date, userDateFormats[this.dateStyle - 1], this.dateStyle, this.isBlankable);
                if (tempDate == null) {
                  showInvalidDateMessage(this.clLabel);
                  return "";
                } else {
                  return tempDate;
                }
            }
            if(!datePresent && timePresent){
                var tempTime = formatTime(date, userTimeFormat, this.timeStyle, this.isBlankable);
                if (tempTime == null) {
                  showInvalidTimeMessage(this.clLabel);
                  return "";
                } else {
                  return tempTime;
                }
            }
            if(datePresent && timePresent){
                var tempDateTime = formatDateTime(date, userDateFormats[this.dateStyle - 1],
                                                  userTimeFormat, this.dateStyle,this.timeStyle, this.isBlankable);
                if (tempDateTime == null) {
                  showInvalidDateTimeMessage(this.clLabel);
                  return "";
                } else {
                  return tempDateTime;
                }
            }
            if(!datePresent && !timePresent){
                var tempDateTime = formatDateTime(date, userDateFormats[0], userTimeFormat, 1, 1, this.isBlankable);
                if (tempDateTime == null) {
                  showInvalidDateTimeMessage(this.clLabel);
                  return "";
                } else {
                  return tempDateTime;
                }
            }
        }
    }
    return "";
}

/**
 * Function to validate the input and format the date for display
 */
function dateField_formatDateOnServer(dateString, isTimestamp, isBlankable) {
    if (isBlankable && dateString == BLANK_FIELD_TEXT) {
      this.setValue(BLANK_FIELD_TEXT);
      this.setValueElement(BLANK_FIELD_TEXT);
      this.validatingOnServer = false;
      return;
    }
    var inTimestampFormat = "false";
    if((isTimestamp != '') && (isTimestamp == true)){
        inTimestampFormat = "true";
    }

    //replace all the space characters with '|' within the strings that are
    //passed as parameters in the request to the server. Netscape 4x requires this.
    dateString = trimString(dateString);
    var params = 'dateString=' + cl_escape(dateString) + '&';
    params += 'dateStyle=' + this.dateStyle + '&';
    params += 'timeStyle=' + this.timeStyle + '&';
    params += 'formName=' + escape(this.formName) + '&';
    params += 'elementName=' + escape(this.element.name) + '&';
    params += 'label=' + escape(this.clLabel) + '&';
    params += 'inTimestampFormat=' + inTimestampFormat;
    if (encodeServletParams) {
        src = dateValidateJSP + encodeURIComponent(params);
    } else {
        src = dateValidateJSP + params;
    }
    // Set a blocking flag to tell whether the server is still validating.
    this.validatingOnServer = true;
    IFrame.setSrc(src);
}

function dateField_setValueElement(timestamp) {
    if(this.valueElement != null) {
        this.valueElement.value = timestamp;
    }
}
/**
 *  Added for popup. This sets itself to be accessible easily from the window
 *  so the popup can get to this element, figures out how big the window
 *  should be based on date and time formats, and opens a popup.
 */
function openDateTimeChooser() {
   if (!this.isEnabled) {
     return;
   }
   var objectName = this.name + DFPopupNamePostFix;
   window.document[objectName] = this;
   // window size depends on whether it shows date, time or both
   var width = datePopupWidth;
   var height = datePopupHeight;
   if(this.dateStyle==4) { // time only
       height = datePopupTimeOnlyHeight;
   }
   if(this.timeStyle==4) { // date only
       height = datePopupDateOnlyHeight;
   }
   var parameters = "INITIAL_DATE="+this.valueElement.value+
                    "&DATE_FORMAT="+this.dateStyle+
                    "&TIME_FORMAT="+this.timeStyle+
                    "&IS_BLANKABLE="+this.isBlankable;

   var urlLoc;
   if (encodeServletParams) {
       urlLoc = datePopupServlet + encodeURIComponent(parameters);
   } else {
       urlLoc = datePopupServlet + parameters;
   }

   // calculate where on the screen the popup should go, first try to get the location
   // of the event that got us here. Default values to 100 in case we don't get such an event.
   var myscreenx = 100;
   var myscreeny = 100;
   if(window.event) {
     myscreenx = window.event.screenX;
     myscreeny = window.event.screenY;
   }
   var popupLocation = calculatePopupLocation(width,height,myscreenx,myscreeny);
   window.open(urlLoc, objectName, "toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=no,resizable=no,copyhistory=no,"+popupLocation+",width="+width+",height="+height);
}

/**
 * Helper function to pop up the window right next to the image the user clicked
 * It takes in teh width and height of the popped up window so that it can avoid
 * giving a location that causes th ewindow to be off of the screen
 * If the window is too far down or to the right, the coordinate is altered so that
 * the user will be able to see the entire popped up window.
 * For this function to be useful, the click must be an event so the
 * href that we surround our icons with must use the onclick event rather than
 * the href part of the link.
 */
function calculatePopupLocation(width, height, eventx, eventy) {
  // we need the screen size
  var screenHeight = window.screen.availHeight-40; // 40 pixel fudge factor for windows toolbars
  var screenWidth = window.screen.availWidth-40; // 40 pixel fudge factor for windows toolbars
  var x = 100;
  if(eventx) {
    x = eventx;
  }
  var y = 100;
  if(eventy) {
    y = eventy;
  }
  // now we make sure that y+height is less than screenHeight
  if(y+height > screenHeight) {
    y = screenHeight-height;
  }
  // and that y+width os less than screenWidth
  if(x+width > screenWidth) {
    x = screenWidth-width;
  }
  return "left="+x+",top="+y+",screenX="+x+",screenY="+y;
}

/**
 *  DateField javscript object definition.
 */
function DateField(label, element, valueElement, required, emptyString, tokenName,  visibleTokenName, dateStyle, timeStyle, form, pairName, isBlankable, isEnabled) {
    this.clLabel = label;
    this.name = element.name;
    this.element = element;
    this.valueElement = valueElement;
    this.formName = form;
    this.required = required;
    this.emptyString = emptyString;
    this.dateStyle = dateStyle;
    this.timeStyle = timeStyle;

    this.ruleChange = dateField_ruleChange;
    this.RuleArray = new Array();

    this.validatedOnServer = true;
    // Set before the jsp is executed to validate on the server and unset when done.
    this.validatingOnServer = false;
    if (valueElement) {
        this.tokenValue = decode(valueElement.value);
    }
    else {
        this.tokenValue = "";
    }
    this.errorCall = null;
    this.defaultOnChange = this.element.onchange;
    this.element.onblur = dateFieldOnBlur;
    this.element.onchange = dateFieldOnChange;
    this.element.onfocus = dateFieldOnFocus;
    if(tokenName != ""){
        new Token(tokenName, this, false, form);
    }
    if(visibleTokenName != ""){
        new Token(visibleTokenName, this, true, form);
    }
    this.defaultClass = 'field-value-nopad'; // useful for switching back from disabled
    this.disabledClass = 'disabled-field-value-m'; // should be passed in as a param in the future
    this.isEnabled = isEnabled;
    this.pairName = pairName;
    this.isBlankable = isBlankable;
}

// enables or disables a dateField
function dateField_setEnabled(flag) {
    if(flag) {
        this.isEnabled = true;
        // set the field's disabled property to be false in IE & Netscape7
        this.element.disabled = false;
        this.element.className = this.defaultClass;
        document[this.name+dateFieldImageNameSuffix].src = dateTimeImgSrc;
    } else {
        waitForServerReturn('document.'+this.formName+'.'+this.name,
        'window.'+this.formName+'.'+this.name+'.disable()', true);
    }
}

// disables a date field object
// do NOT call directly.  only call from dateField_setEnabled()
// this method should process only after a field is finished validating
function dateField_disable() {
    this.isEnabled = false;
    this.element.disabled = true;
    this.element.className = this.disabledClass;
    document[this.name+dateFieldImageNameSuffix].src = dateTimeDisabledImgSrc;
}

function dateField_getValue() {
    return this.tokenValue;
}

new DateField("", "", false, "", "", "", "", "", "", "", false, true);
DateField.prototype.validate = _validateDateField;
DateField.prototype.getTokenValue = dateField_getTokenValue;
DateField.prototype.getLabel = getLabel;
DateField.prototype.setValue = dateField_setValue;
DateField.prototype.getValue = dateField_getValue;
DateField.prototype.getValueForRule = dateField_getValue;
DateField.prototype.isCodeString = no_codestring;
DateField.prototype.date_fmtValue = dateField_fmtValue;
DateField.prototype.formatDateOnServer = dateField_formatDateOnServer;
DateField.prototype.setValueElement = dateField_setValueElement;
DateField.prototype.callBack = dateField_callBack;
DateField.prototype.onclick = openDateTimeChooser;
DateField.prototype.addListener = rules_addListener;
DateField.prototype.chkValue = rules_chkValue;
DateField.prototype.setEnabled = dateField_setEnabled;
DateField.prototype.disable = dateField_disable;
DateField.prototype.setRequired = generic_setRequired;

// preload autocomplete enabled and disabled images
dateTimeImg = new Image();
dateTimeImg.src = dateTimeImgSrc;
dateTimeDisabledImg = new Image();
dateTimeDisabledImg.src = dateTimeDisabledImgSrc;

/**
 * A dummy object for invoking the corresponding functions
 * if validation of input fails on the server
 */
var DummyDateField = new Object();
DummyDateField.showInvalidDateMessage = showInvalidDateMessage;
DummyDateField.showInvalidTimeMessage = showInvalidTimeMessage;
DummyDateField.showInvalidDateTimeMessage = showInvalidDateTimeMessage;
DummyDateField.showInvalidDateTimeValueMessage = showInvalidDateTimeValueMessage;

/**
 *  END DATEFIELD OBJECT
 */


/**
 *  BEGIN WEBADDRESS OBJECT
 */
/**
 *  a duplicate of text field
 */
function _validateWebAddress(forceCheck) {
    this.element.value = trimString(this.element.value);

    //error if required and trimmed value matches empty value
    if(checkRequired && (this.required || (forceCheck != null && forceCheck)) &&
       (this.element.value==this.emptyString)) {
        requiredAlert(this.clLabel);

        return false;
    }
    return true;
}

function webaddress_onchange() {
    var obj = findJSOForElement(this);
    if(obj.RuleArray.length > 0) {
	    RuleUtil.isPendingFlag = true;
        RuleUtil.evaluateRules(obj.RuleArray, obj.getValue(), obj.isCodeString());
    } else {
        RuleUtil.isPendingFlag = false;
        resumeOnclickEvents();
    }
}

/**
 *  WebAddress javascript object definition.
 */
function WebAddress(label, element, required, emptyString, tokenName,  visibleTokenName, form) {
    this.clLabel = label;
    this.name = element.name;
    this.element = element;
    this.required = required;
    this.emptyString = emptyString;
    this.element.onchange = webaddress_onchange;
    this.RuleArray = new Array();

    if(tokenName != ""){
        new Token(tokenName, this, false, form);
    }
    if(visibleTokenName != ""){
        new Token(visibleTokenName, this, true, form);
    }
}

new WebAddress("", "", false, "", "", "");
WebAddress.prototype.addListener = rules_addListener;
WebAddress.prototype.validate = _validateWebAddress;
WebAddress.prototype.getTokenValue = std_getTokenValue;
WebAddress.prototype.setEnabled = textField_setEnabled;
WebAddress.prototype.getLabel = getLabel;
WebAddress.prototype.setValue = textField_setValue;
WebAddress.prototype.setRequired = generic_setRequired;
WebAddress.prototype.getValue = textfield_getValue;
WebAddress.prototype.getValueForRule = textfield_getValue;
WebAddress.prototype.isCodeString = no_codestring;
WebAddress.prototype.text_fmtValue = textField_fmtValue;

/**
 *  END WEBADDRESS OBJECT
 */

/**
 *  BEGIN FILECHOOSER OBJECT
 */

/**
 * disassociateAttachment method is used to disassociate an already uploaded file to a field in an entity.
 * This is called when the Remove Button of the Attachment component is clicked.
 *
 * @param    fileLink link containing the filename currently associated.
 * @param    hiddenName hidden element that keeps the system filename of the attachment.
 * @param    remove the enabled remove button
 * @param    removeOff the disabled remove button
 * @param    NO_DOC hidden element containing the text '(no document attached)'
 */
function disassociateAttachment(formTxt, htmlTxt, fileLink, hiddenName, remove, removeOff, NO_DOC) {
    fileLink.innerHTML = NO_DOC;
    hiddenName.value = '';
    remove.style.display='none';
    removeOff.style.display='inline';

	// Now, we need to set the hidden value of the filechooser to empty string
    var obj = findJSOForElement(document[formTxt][htmlTxt]);
    obj.setEmpty();
    if( obj.getRuleArray() && obj.getRuleArray().length > 0 ) {
	    RuleUtil.isPendingFlag = true;
        RuleUtil.evaluateRules(obj.getRuleArray(), obj.getValue(), obj.isCodeString());
    }
}

function setEmpty() {
    this.emptyString = "";
}
/**
 *  validation method of the filechooser.
 */
function _validateFileChooser(forceCheck) {
    //can't affect file chooser's actual value
    var trimmed = trimString(this.element.value);

    //error if required and trimmed value matches empty value
    if(checkRequired &&
    	(this.required || (forceCheck != null && forceCheck)) &&
    	(
    	 (trimmed=='') ||
    	 (trimmed=='0.0..' && this.emptyString=='0.0..')
    	)
    ) {
        requiredAlert(this.clLabel);

        return false;
    }
    return true;
}

function filechooser_onChange(elem) {
    var jsObj = findJSOForElement(elem);
    if( jsObj && jsObj.RuleArray && jsObj.RuleArray.length > 0 ) {
	    RuleUtil.isPendingFlag = true;
        RuleUtil.evaluateRules(jsObj.RuleArray, jsObj.getValue(), jsObj.isCodeString());
    }
}

function filechooser_setEnabled(flag) {
    this.isEnabled = flag;
    this.element.disabled = !flag;
}

function filechooser_getValue() {
    return this.element.value;
}

function filechooser_setValue(value) {
    // functionality is not to set a value for attachments
    // we will only clear the value
    if( value == '' ) {
        disassociateAttachment(this.formTxt, this.htmlTxt, this.fileLink, this.hiddenName, this.remove, this.removeOff, this.NO_DOC);
    }
    // else, do nothing
}

function filechooser_getRuleArray() {
    return this.RuleArray;
}

/**
 * In order to use additonal parameter to check the hidden value for
 * the file attachment. For fileChooser, emptyString is used to
 * pass the hiddenFile value. It is not used as emptyString here.
 */
function FileChooser(label, name, element, required, emptyString, tokenName,  visibleTokenName, form, htmlTxt, fileLink, hiddenName, remove, removeOff, NO_DOC) {
    this.clLabel = label;
    this.name = name;
    this.element = element;
    this.required = required;
    this.emptyString = emptyString;
    this.RuleArray = new Array;
    this.isEnabled = true;
    this.formTxt = form;
    this.htmlTxt = htmlTxt;
    this.fileLink = fileLink;
    this.hiddenName = hiddenName;
    this.remove = remove;
    this.removeOff = removeOff;
    this.NO_DOC = NO_DOC;
    if(tokenName != ""){
            new Token(tokenName, this, false, form);
        }
    if(visibleTokenName != ""){
            new Token(visibleTokenName, this, true, form);
    }
}

new FileChooser("", "", "", false, "", "", "");
FileChooser.prototype.addListener = rules_addListener;
FileChooser.prototype.validate = _validateFileChooser;
FileChooser.prototype.getTokenValue = std_getTokenValue;
FileChooser.prototype.getLabel = getLabel;
FileChooser.prototype.setEmpty = setEmpty;
FileChooser.prototype.getValue = filechooser_getValue;
FileChooser.prototype.getValueForRule = filechooser_getValue;
FileChooser.prototype.setValue = filechooser_setValue;
FileChooser.prototype.setRequired = generic_setRequired;
FileChooser.prototype.setEnabled = filechooser_setEnabled;
FileChooser.prototype.isCodeString = no_codestring;
FileChooser.prototype.getRuleArray = filechooser_getRuleArray;

/**
 *  END FILECHOOSER OBJECT
 */


/**
 *  BEGIN PASSWORD OBJECT
 */


/**
 *  the method is called whenever a user clicks Ok button
 *  in the password popup dialog.
 */
function pw_popup_onclick(){
    element = window.opener.document[window.name];
    handlePasswordSelections(element);
    pw_window_close();
}

// Handle closing an password window.
function pw_window_close() {
    window.close();
}


/**
 * set the value to the field on the parent page.
 */
function handlePasswordSelections(element) {
    var undefined;
    var passValue;
    if (element == undefined) {
        return;
    }
    var parent;
    if(window.opener != undefined) {
        parent = window.opener;
    } else {
        parent = window.parent;
    }
    if (document["passwordForm"]["PASSWORD"] != undefined) { //means it returns no rows in autocomp
        passValue = document["passwordForm"]["PASSWORD"].value;
        element.setValue(passValue);
    }
    element.handleRules();
}
function password_reset(ChangeImg, EnterImg){
    if(this.initiallyBlank==false){
        document.getElementById(this.passwordprompt).innerHTML = passwordMask;
        document[this.passwordimg].src = ChangeImg.src;
    }else{
        document.getElementById(this.passwordprompt).innerHTML = passwordBlank;
        document[this.passwordimg].src = EnterImg.src;
    }
}

var PWPopupNamePostFix = "PWPopup";

/**
 *  Opens the Password Dialog page.
 */
function password_onClick(){
    if (this.isEnabled) {

        var objectName = this.name + PWPopupNamePostFix;
        document[objectName] = this;

        var undefined;

       /**
        * Same as the Autocomplete code - PS
        * Workaround for all IE browsers. When the autocomplete window is open, and user clicks on
        * the icon again, it was giving a javascript error "Access Denied". Request# 79295
        */
       if (navigator.appName.indexOf("Netscape") == -1) {
            if (popup != undefined) {
                popup.close();
            }
       }
       // calculate where on the screen the popup should go
       var myscreenx = 100;
       var myscreeny = 100;
       if(window.event) {
         myscreenx = window.event.screenX;
         myscreeny = window.event.screenY;
       }
       var popupLocation = calculatePopupLocation(passwordWidth,passwordHeight, myscreenx, myscreeny);
       popup = window.open(BLANK_PAGE,
                            objectName,
                            popupLocation+",toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=yes,resizable=yes,copyhistory=no,width=" + passwordWidth + ",height=" + passwordHeight);

       // we need to manually set the cookie in the popup window because IE4 doesn't send it
        var allcookies = document.cookie;
        var pos = allcookies.indexOf("JSESSIONID=");

        // now we can forward to the Password.jsp
        newLoc = getHostPath() +
                 passwordPopupServletPath +
                 "&IS_WINDOID=Y"+
                 "&FIELD_NAME=" + encodeURIComponent(this.name) +
                 "&FIELD_LABEL=" + encodeURIComponent(this.clLabel) +
                 "&KEY=" + getUniqueKey();


        // other browsers can reload the popup window themselves
        popup.document.writeln(globalStyleSheet);
        var callback = 'this.window.opener.document["' + objectName + '"].windowIsOpen = false';
        popup.document.writeln("<html><head><title>Kintana Password</title><SCRIPT>"+getPopupLocation(newLoc,this)+"</SCRIPT></head><body bgcolor=white onUnload='"
                               + callback + "'><center><h1><font face=verdana>" + loadingMessage + "</font></h1></center></body></html>");
    }
    return;
}

function password_setValue( value ) {
    // If the password field has a value then set the password prompt to '*****'
    // and the button to 'Change'
    this.element.value = value;
    if ( value != "" ) {
        document.getElementById(this.passwordprompt).innerHTML = passwordMask;
        document.getElementById(this.name).innerHTML =
           '<a href="javascript:window.'+document.forms[0].name+'.'+this.name+'.onclick();">Change</a>';
    } else {
        // Set the password prompt to '(blank)' and the button to 'Enter'
        document.getElementById(this.passwordprompt).innerHTML = passwordBlank;
        document.getElementById(this.name).innerHTML =
            '<a href="javascript:window.'+document.forms[0].name+'.'+this.name+'.onclick();">Enter</a>';
    }
}

function password_getValue() {
    return this.element.value;
}

function password_setPrompt ( value ) {
    this.promptElement.value = value;
}

/**
 * Adding this function (even though we do not need it) as the Token.getValue() actually calls Token.parent.getTokenValue()
 * and password component did not have it.
 * Also returning empty strings as we do not resolve password tokens in the client
 */
function password_getTokenValue(isVisible) {
    return decode(this.element.value, isVisible);
}

/**
 *  Validate method for javascript hidden field object.
 */
function _validatePassword(forceCheck) {
    if((this.required || (forceCheck != null && forceCheck)) &&
       (this.element.value==this.emptyString)) {
        requiredAlert(this.clLabel);
        return false;
    } else {
        return true;
    }
}

function password_handleRules() {
    if( this.RuleArray.length > 0 ) {
	    RuleUtil.isPendingFlag = true;
        RuleUtil.evaluateRules(this.RuleArray, this.getValue(), this.isCodeString());
    }
}

function password_setEnabled(flag) {
    this.isEnabled = flag;
}

/**
 *  Password javascript object definition.
 */
function Password(label, element, promptElement, passwordprompt, passwordimg, tokenName, visibleTokenName, required, emptyString, isEnabled, form, initiallyBlank) {

    this.name = element.name;
    this.element = element;
    this.clLabel = label;
    this.promptElement = promptElement;
    this.passwordprompt = passwordprompt;
    this.passwordimg = passwordimg;
    this.required = required;
    this.form = form;
    this.isEnabled = isEnabled;
    this.RuleArray = new Array;
    if(tokenName != ""){
        new Token(tokenName, this, false, form);
    }
    if(visibleTokenName != ""){
        new Token(visibleTokenName, this, true, form);
    }
    this.emptyString = emptyString;
    this.initiallyBlank = initiallyBlank;
}

new Password("", "", "", "", "", "", "", "", "", "","","");
Password.prototype.validate = _validatePassword;
Password.prototype.addListener = rules_addListener;
Password.prototype.getLabel = getLabel;
Password.prototype.getValue = password_getValue;
Password.prototype.getValueForRule = password_getValue;
Password.prototype.setEnabled = password_setEnabled;
Password.prototype.setRequired = generic_setRequired;
Password.prototype.isCodeString = no_codestring;
Password.prototype.handleRules = password_handleRules;
Password.prototype.getTokenValue = password_getTokenValue;
Password.prototype.setValue = password_setValue;
Password.prototype.onclick  = password_onClick;
Password.prototype.chkValue = rules_chkValue;
Password.prototype.setPrompt = password_setPrompt;
Password.prototype.reset = password_reset;


/**
 *  END PASSWORD OBJECT
 */



/**
 *  BEGIN HIDDENFIELD OBJECT
 */
/**
 *  Validate method for javascript hidden field object.
 */
function _validateHiddenField(forceCheck) {
    if(forceCheck && (this.element.value == "" || this.element.value == "0.0..")) {
        requiredAlert(this.clLabel);
        return false;
    } else {
        return true;
    }
}

function hid_isNotEmpty() {
    if(this.element.value == "" || this.element.value == "0.0..") {
        return false;
    }
    return true;
}

/**
 *  HiddenField javascript object definition.
 */
function HiddenField(clLabel, element, tokenName, visibleTokenName, form) {
    this.clLabel = clLabel;
    this.element = element;
    this.form = form;
    this.focusable = false;
    this.currentCSValue = element.value;
    this.RuleArray = new Array;
    if(visibleTokenName != ""){
        new Token(visibleTokenName, this, true, form);
    }
    if(tokenName != ""){
        new Token(tokenName, this, false, form);
    }
}

function hid_setValue(hidVal) {
    this.element.value = hidVal;
    this.currentCSValue = hidVal;
}

function hid_getValue() {
    return this.element.value;
}

/**
 * the javascript escape function doesn't replace '+' which we use
 * to outer join in our sql. This escape does that.
 */
function cl_escape(str){
    // first do the standard javascript replace
    escaped = escapeForURI(str);
    // replace all '+' from outer joins and return the string
    return escaped.replace(/\+/g,"%2B");
}

new HiddenField("", "", "", "");
HiddenField.prototype.addListener = rules_addListener;
HiddenField.prototype.validate = _validateHiddenField;
HiddenField.prototype.getTokenValue = std_getTokenValue;
HiddenField.prototype.getLabel = getLabel;
HiddenField.prototype.getValue = hid_getValue;
HiddenField.prototype.getValueForRule = hid_getValue;
HiddenField.prototype.setValue = hid_setValue;
HiddenField.prototype.isNotEmpty = hid_isNotEmpty;
HiddenField.prototype.chkValue = rules_chkValue;
// it doesn't make sense to make a hidden field required.
// the current functionality is to ignore this configuration error.
// same with display only... since hidden fields are already "not displayed."
HiddenField.prototype.setRequired = noop;
HiddenField.prototype.setEnabled = noop;
HiddenField.prototype.isCodeString = no_codestring;

/**
 *  END HIDDENFIELD OBJECT
 */

/**
 * Validation an array of buttons. Works with
 * a single button as well because it checks to
 * see if the array parameter is an array. Javascript
 * sucks...no type checking.
 */
function validateButtonArray(array){
    var checked = false;
    var undefRef; // reference for undefined
    // make sure it is an array
    if(array.length == undefRef){
        // not an array, just check the single value
        checked = array.checked;
    } else {
        // array of buttons, look for a check
        for(i=0;i<array.length;i++){
            if(array[i].checked){
                checked = true;
            }
        }
    }
    return checked;
}

/**
 *  Inorder for token parsing to work correctly a complete token name has to
 *  be build when building express components.
 *  ie. for the field createdby the token should start with "I." so the correct format
 *  is 'I.CREATED_BY_NAME' instead of just 'CREATED_BY_NAME'.
 */

var UNRESOLVED = "UNRESOLVED";
var pageTokens = new Array();
Array.prototype.push = _push;

/**
 *  prototype push method for arrays.
 *  This method is already implemented inside Netscape browsers.
 */
function _push(item){
    this.length++;
    this[this.length-1] = item;
}
Array.prototype.pop = _pop;
/**
 *  prototype pop method for arrays.
 *  This method is already implemented inside Netscape browsers.
 */
function _pop(){
    var item = this[this.length-1];
    this.length--;
    return item;
}

/**
 *  Creates a standard token object
 */
function Token(tokenName, element, isVisible, formName){
    this.name = tokenName;
    this.parentElement = element;
    this.isVisibleToken = isVisible;
    this.formName = formName;
    if(isVisible == true){
        element.visibleTokenName = tokenName;
    }else{
        element.tokenName = tokenName;
    }
    this.getValue = _getValue;

    if(pageTokens[this.formName] == null) {
        pageTokens[this.formName] = new Array();
    }
    if(tokenName != "" || tokenName != "undefined"){ //\\ this looks reaklly strange... shouldn't it be && instead of || ????
        pageTokens[this.formName][tokenName] = this;
        //Added to be able to iterate through pageTokens array.
        pageTokens[this.formName][pageTokens.length++] = pageTokens[this.formName][tokenName];

        //make sure tokens without the "P." prefix can also work in kintana interface
        //however we also want to make sure that token without prefix resolve to P., not VP.
        //for example, [TOKEN] = [P.TOKEN] while in some cases [TOKEN] != [VP.TOKEN].
        //alert ("Token Name "+tokenName );
        if (!isVisible && tokenName.lastIndexOf(".") != -1)
        {
           if (tokenName.length != tokenName.lastIndexOf("."))
           {
               pageTokens[this.formName][tokenName.substring(tokenName.lastIndexOf(".")+1, tokenName.length)] = this;
               pageTokens[this.formName][pageTokens.length++] = pageTokens[this.formName][tokenName];
           }
        }
    }
}
/**
 *  A prototype method for the VisibleToken and Token object.
 */
function _getValue(){
    return this.parentElement.getTokenValue(this.isVisibleToken);
}
function resolveTokens(str, formName){
    return resolveToken(tokenizeBetween('[',']',str), str, formName, false);
}
function resolveTokensQuiet(str, formName){
    return resolveToken(tokenizeBetween('[',']',str), str, formName, true);
}
/**
 *  Utility method to resolve the tokens within str variable.
 *  If quiet is true then allow tokens to resolve to empty
 *  strings without complaint.
 */
function resolveToken(tokenList, str, formName, quiet){
    var output = "";
    var regExp = null;
    var oldShowAlert = showAlert;

    if (quiet) {
    	showAlert=false;
    }

    for(var i=0;i<tokenList.length;i++){
        var tableTokenFlag = false;
        if(tokenList[i].indexOf(REQ_TABLE_TOKEN_PREFIX) == 0){
            //starts with a table token
            tableTokenFlag = true;
            var tableCompTokenName = TableUtils.getTableTokenPrefix(tokenList[i]);
            var tableCompToken = getCorrectTokenFormat(tableCompTokenName, formName);
            if(tableCompToken != undef){
                element = tableCompToken.getElement(tokenList[i],quiet);
            }
        }else{
            element = getCorrectTokenFormat(tokenList[i], formName);
        }
        if(element != null){
            // replace "#@#" with ", " in multi-value cases
            var tempValue = element.getValue();
            var segments = tempValue.split(MULTIAUTO_DELIMITER);
            tempValue = segments[0];
            for (var j=1; j<segments.length; j++) {
                tempValue = tempValue + COMMA_SPACE + segments[j];
            }
            output = tempValue;
            if(quiet == undef || quiet == false) {
                if(output == ""){
                    return UNRESOLVED;
                }
            }
            regExp = new RegExp("\\[" + tokenList[i] + "\\]");
            str = str.replace(regExp, output);
        }
    }
    showAlert=oldShowAlert;
    return str;
}
/**
 *  hash PageTokens if needed
 */
function hashPageTokens(parentFormName, parentPageTokens, childFormName, childPageTokens){
    if(!hashParentChildPageTokens || parentPageTokens==undef){
        //don't need to hash
        return;
    }
    for(var prop in parentPageTokens[parentFormName]){
        if(prop.indexOf("REQ")!=-1){
            childPageTokens[childFormName][prop] = parentPageTokens[parentFormName][prop];
        }
    }
    window.status = closingParentRequestWarningMessage;
}

/**
 *  get correct token format, appends 'REQD' to the following
 *  tokens starting with.
 *  'P.', 'VP.', 'UD.', 'VUD.'.
 */
function getCorrectTokenFormat(token, formName){
    if (pageTokens[formName] == null) {
      return null;
    }
    element = pageTokens[formName][token];
    if(element == null){
        token = token.replace(/^P\./g, "REQD.P.");
        token = token.replace(/^VP\./g, "REQD.VP.");
        token = token.replace(/^UD\./g, "REQD.UD.");
        token = token.replace(/^VUD\./g, "REQD.VUD.");
        element = pageTokens[formName][token];
    }
    return element;
}

/**
 * Given a token and a formName, return the object
 */
function getTokenElement(token, formName) {
    if(getCorrectTokenFormat(token, RuleUtil.formName)) {
        return getCorrectTokenFormat(token, RuleUtil.formName).parentElement;
    }
    return null;
}

/**
 *  Utility method to tokenize a str between startDelim and endDelim.
 */
function tokenizeBetween(startDelim, endDelim, str){
    stack = new Array();
    tokens = new Array();
    var lastStartDelimIndex = -1;
    for(var i=0;i<str.length;i++){
        if(str.charAt(i) == startDelim){
            stack.push(i);
        }else if(str.charAt(i) == endDelim){
            if(stack.length != 0){
                lastStartDelimIndex = stack.pop();
                tokens.push(str.substring(lastStartDelimIndex+1,i));
                lastStartDelimIndex = -1;
            }
        }
    }
    return tokens;
}

/**
 *  Utility method to get all the non-empty tokens on this page.
 *
 * passing in tokenName and visibleTokenName to avoid an infinite recursion
 * that happens when .getValue() method is called on the token stored in pageTokens[][]
 * array.
 */
function resolvePageTokens(formName, sourceTokenName, sourceVisibleTokenName) {
    var undefined;
    if (pageTokens[formName] == null) {
        return null;
    }

    var oldShowAlert = showAlert;

    showAlert=false;
    resolvedPageTokens="";
    for (var i=0; i<pageTokens[formName].length; i++) {

        if (pageTokens[formName][i] != null &&
            pageTokens[formName][i].name != sourceTokenName &&
            pageTokens[formName][i].name != sourceVisibleTokenName) {

            var temp = pageTokens[formName][i].getValue();
            if (temp != undefined && temp != "") {
                var element1=pageTokens[formName][i];
                resolvedPageTokens=resolvedPageTokens+element1.name+"#!#"+temp+"#!#";
            }
        }
    }

    showAlert=oldShowAlert;
}

/**
 *  Confirm Override
 */
function confirmOverride(element, overrideActionName){
    if(confirm(confirmOverrideMsg)){
        var hiddenFieldObj = findJSOForElement(element);
        hiddenFieldObj.setValue(overrideActionName);
        document[hiddenFieldObj.form].submit();
    }
}

/**
 *  Confirm Cancel
 */
function confirmCancel(element, cancelActionName){
    if(confirm(confirmCancelMsg)){
        var hiddenFieldObj = findJSOForElement(element);
        hiddenFieldObj.setValue(cancelActionName);
        document[hiddenFieldObj.form].submit();
    }
}
/**
 *  Confirm Reopen
 */
function confirmReopen(element, reopenActionName){
    if(confirm(confirmReopenMsg)){
        var hiddenFieldObj = findJSOForElement(element);
        hiddenFieldObj.setValue(reopenActionName);
        document[hiddenFieldObj.form].submit();
    }
}

/**
 * Format messages.
 */
function formatMessage() {
    var fmt = arguments[0];
    var param = null;
    for(var i=1;i<arguments.length;i++) {
        param = '\\{' + (i-1) + '\\}';
        fmt = fmt.replace(new RegExp(param, "g"), arguments[i]);
    }
    return fmt;
}
/**
 ** The RuleUtil Object
 **/
/**
 * If after the rules are processed there is no workflow specified, this
 * one will be put in the workflow field.
 */
function rules_setDefaultWorkflow(workflow) {
    this.defaultWorkflow = workflow;
}

/**
 * Need to know the formname for client side token parsing. Since the RuleObject
 * is a static object, only one form per page can have rule handling.
 */
function rules_setFormName(formName) {
    this.formName = formName;
}

function rules_setReloadFlag(value) {
    this.reloadFlag = value;
}

function rules_setChangeRequestTypeFlag(value) {
    this.changeRequestTypeFlag = value;
}

function rules_setCopyRequestFlag(value) {
    this.copyRequestFlag = value;
}

function rules_evaluateRules(JSRuleArray, dependentValue, isCodeString) {
    var rulesToApply = new Array;
    var l = JSRuleArray.length;
    // Start indexing at 1 because rule sequences start at one.
    for (var i = 1; i<l; i++) {
        if(JSRuleArray[i] == undef) {
            continue;
        }
        // applyRules is a misnomer because we actually want to send it
        // to the server to evaluate the rule.  if the rule is evaluated
        // on the server side, then the server will generate the
        // appropriate JS to set the fields' values.
        if(JSRuleArray[i].ruleType == CLEAR ||
           JSRuleArray[i].ruleType == DISPLAY_ONLY ||
           JSRuleArray[i].ruleType == REQUIRED) { // don't need to check isValid().
            // isValid() checks whether it matches all or matches by a particular value.
            // isValid() --> JSRule().isValid() --> Dependant.isValid()
            JSRuleArray[i].setDependentValue(dependentValue);
            JSRuleArray[i].setCodeString(isCodeString);
            rulesToApply[rulesToApply.length] = JSRuleArray[i];
        } else if(JSRuleArray[i].event == ON_CREATION || JSRuleArray[i].isValid()) {
            // For on creation rules we don't check any dependant fields.
            JSRuleArray[i].setDependentValue(dependentValue);
            JSRuleArray[i].setCodeString(isCodeString);
            rulesToApply[rulesToApply.length] = JSRuleArray[i];
            if(JSRuleArray[i].event == ON_FLD_CHNGE_AND_STOP_RULES) {
                break;
            }
        }
    }
    if(rulesToApply.length > 0) {
        RuleUtil.applyRules(rulesToApply);
    }else{
        RuleUtil.isPendingFlag = false;
        resumeOnclickEvents();
    }
    return rulesToApply.length;
}

function rules_createInput(name, value) {
    var input = '\n<input type="hidden" name="';
    input += name;
    input += '" value="';
    input += escapeForHTML(String(value));
    input += '">';
    return input;
}

/*
 * sequence + RULE_DELIMITER
 * tokens + RULE_DELIMITER
 * traversedTokens + RULE_DELIMITER
 * dependentValue
 */
function rules_createInputRuleInfo(rule) {
    var inputValue = rule.sequence + RULE_DELIMITER;
    var tokensInput = '';
    var tokens = rule.tokens;
    if( tokens ) {
        tokensInput = resolveTokensQuiet(tokens, RuleUtil.formName);
    }
    inputValue += tokensInput + RULE_DELIMITER;

    tokensInput = '';
    var travTokens = rule.getTraversedTokens();
    if( travTokens && travTokens != undef &&
        travTokens != '' && travTokens != null &&
        travTokens.length > 0 ) {
        for( i = 0; i < travTokens.length-1; i++ ) {
            tokensInput += travTokens[i] + RULE_TOKEN_DELIMITER;
        }
        if( travTokens.length > 0 ) {
            tokensInput += travTokens[travTokens.length-1];
        }
    }
    inputValue += tokensInput + RULE_DELIMITER;

    var depVal = rule.getDependentValue();
    if( depVal && depVal != undef && depVal != '' ) {
        inputValue += depVal + RULE_DELIMITER;
    } else {
        inputValue += RULE_DELIMITER;
    }

    var isCS = rule.isCodeString();
    inputValue += isCS;

    return inputValue;
}

/**
 * Construct the parameters to be passed to the server and call the server.
 */
function rules_applyRules(ruleArray) {
    var formInput = '';
    var l = ruleArray.length;
    for ( var i = 0; i < l; i++ ) {
        var inputRuleInfo = rules_createInputRuleInfo(ruleArray[i]);
        ruleArray[i].setTraversedTokens('');
        ruleArray[i].setDependentValue('');
        ruleArray[i].isCodeString('');
        formInput += rules_createInput(RULES_PARAM,
                                       inputRuleInfo);
    }
    if(RuleUtil.mode == RuleUtil.RULE_MODE_REQUEST){
        formInput += rules_createInput(PARENT_ENTITY_TYPE_ID, REQUEST_TYPE_ENTITY_ID);
        var reqType = getTokenElement('REQ.REQUEST_TYPE_ID',
                                      RuleUtil.formName).getTokenValue(false);
        formInput += rules_createInput(ENTITY_TYPE_ID, reqType);

        var reqIDObj = getTokenElement('REQ.REQUEST_ID', RuleUtil.formName);
        if (reqIDObj) {
            var reqID = reqIDObj.getTokenValue(false);
            formInput += rules_createInput(PRIMARY_KEY, reqID);
        }
    }else if(RuleUtil.mode == RuleUtil.RULE_MODE_TABLE_COMP){
        formInput += rules_createInput(PARENT_ENTITY_TYPE_ID, VALIDATION_ENTITY_ID);
        var valId = RuleUtil.tblValidationId;
        formInput += rules_createInput(ENTITY_TYPE_ID, valId);
    }else if(RuleUtil.mode == RuleUtil.RULE_MODE_REPORT){
        formInput += rules_createInput(PARENT_ENTITY_TYPE_ID, REPORT_TYPE_ENTITY_ID);
        formInput += rules_createInput(ENTITY_TYPE_ID, RuleUtil.rptTypeID);
    }
    formInput += rules_createInput("DATE", new Date()); // To avoid caching.
    // deal with allow external updated
    //#144626
    var object = document.forms[RuleUtil.formName].elements["FMF_KNTA_ALLOW_EXTERNAL_UPDATE"];
    if (object){
      var selection;
      if (object[0]){
        if (object[0].checked)
              selection = "Y";
          else selection = "N";
        }
      else{
          if (object.value == "1.1.Y.Y")
              selection = "Y";
          else
              selection = "N";
        }
      formInput += rules_createInput("FMF_KNTA_ALLOW_EXTERNAL_UPDATE", selection);
    }
    IFrame.setFormInput(autoPopulateController,formInput);
}

function rules_triggerCreateEvent() {
    RuleUtil.existingOnload();
    if(RuleUtil.mode == RuleUtil.RULE_MODE_REQUEST){
        // only apply create rules once at first page load
        if(RuleUtil.formName == 'RequestCreateForm' || RuleUtil.changeRequestTypeFlag) {
            if (RuleUtil.reloadFlag == 'N' && !RuleUtil.copyRequestFlag) {
                if(RuleUtil.evaluateRules(RuleUtil.creationRuleArray,'','') == 0) {
                    // If no rules were processed we still want to trigger the call back.
                    // Otherwise we let the server make the call to the callBack in order to
                    // get the timing right.
                    RuleUtil.callBack();
                    IFrame.callBack();
                }
            } else {
                // this is reload, but we still should set the default workflow
                RuleUtil.callBack();
            }
        }
    }else if(RuleUtil.mode == RuleUtil.RULE_MODE_TABLE_COMP){
        // only apply create rules once at first page load
        if(RuleUtil.formName == 'TEFADD_NEW') {
            if(RuleUtil.evaluateRules(RuleUtil.creationRuleArray,'','') == 0) {
                // If no rules were processed we still want to trigger the call back.
                // Otherwise we let the server make the call to the callBack in order to
                // get the timing right.
                RuleUtil.callBack();
                IFrame.callBack();
            }
        }
    }
}

function rules_setField(token, valueCS, ruleInfoCS) {
    element = getTokenElement(token, RuleUtil.formName);
    if(element) {
        if(RuleUtil.formName == 'WF_EVENT' && token == 'REQ.WORKFLOW_ID') {
            var reqType = getTokenElement('REQ.REQUEST_TYPE_ID', RuleUtil.formName).getTokenValue(true);
            alert(formatMessage(changedWFError, reqType, decode(ruleInfoCS, false), decode(ruleInfoCS, true)));
        }
        else {
        	element.setValue(valueCS, true, decode(ruleInfoCS, false), decode(ruleInfoCS, true));
        }
    }
}

function rules_setDisplayOnly(token,flag) {
    // alert( 'setdisplayonly(' + token + ')' );
    element = getTokenElement(token, RuleUtil.formName);
    // display only is the opposite of enabled
    element.setEnabled(!flag);
}

function rules_setRequired(token,flag){
    // alert( 'setrequired(' + token + ')' );
    element = getTokenElement(token, RuleUtil.formName);
    element.setRequired(flag);
    var tdForReq = document.getElementById(REQ_PREFIX + token);
    if( tdForReq ) {
        if( flag ) {
            tdForReq.innerHTML = REQ_ASTERISK;
        } else {
            tdForReq.innerHTML = '';
        }
    }
}

function rules_setValueFromToken(result,dep,traversedTokens,newRules,ruleSeq,ruleName) {
    // alert( 'setvalue from token(' + result + ',' + dep + ')' );
    depElem = getTokenElement(dep);
    valFromToken = depElem.getValueForRule();
    resultElem = getTokenElement(result);
    if( valFromToken ) {
        resultElem.setValue(valFromToken, true /*noCascade*/, ruleSeq, ruleName);
    } else {
        resultElem.setValue('');
    }
    // add more rules as needed
    rules_addNewRules(resultElem, traversedTokens, newRules );
}

function rules_setClear(result,traversedTokens,newRules) {
    if( 'N' == RuleUtil.firstPass ) {
        resultElem = getTokenElement(result);
        var origCheckReq = checkRequired;
        checkRequired = false;
        resultElem.setValue('');
        checkRequired = origCheckReq;
        // add more rules as needed
        rules_addNewRules(resultElem, traversedTokens, newRules );
    }
}

function rules_addNewRules(resultElem, traversedTokens, newRules ) {
    if( resultElem.RuleArray && resultElem.RuleArray.length > 0 ) {
        for( var i = 1; i < resultElem.RuleArray.length; i++ ) {
            if( resultElem.RuleArray[i] != undef ) {
                if( traversedTokens &&
                    traversedTokens != undef &&
                    traversedTokens != '' &&
                    traversedTokens.length > 0 ) {
                    // copy these tokens
                    var travTokens = new Array();
                    for( var j = 0; j < traversedTokens.length; j++ ) {
                        travTokens[j] = traversedTokens[j];
                    }
                    resultElem.RuleArray[i].setTraversedTokens(travTokens);
                } else {
                    resultElem.RuleArray[i].setTraversedTokens('');
                }
                resultElem.RuleArray[i].setDependentValue(resultElem.getValue());
                resultElem.RuleArray[i].setCodeString(resultElem.isCodeString());
                newRules[newRules.length] = resultElem.RuleArray[i];
            }
        }
    }
}

// A function to handle any finishing logic that needs to happen after the fields have been
// updated from the server. Will also be called if no rules were processed but Rule handling logic
// was triggered.
function rules_callBack() {
    // alert( 'rules_callBack()' );
    if(RuleUtil.formName == 'RequestCreateForm') {
        var workflow = getTokenElement('REQ.WORKFLOW_ID', RuleUtil.formName).getValue();
        if(workflow == '0.0..') {
            var setEmptyCount = 0;
        	//This flag prevents infinite loop when applyRules calls the callBack.
            if(!RuleUtil.setEmptyCalled && RuleUtil.copyRequestFlag) {
                RuleUtil.setEmptyCalled = true;
	            setEmptyCount = RuleUtil.evaluateRules(RuleUtil.creationRuleArray,'','');
            }
            //This works for Request Types without rules and if all Rules use disabled Workflows.
            if(setEmptyCount == 0) {
        	    RuleUtil.setField('REQ.WORKFLOW_ID', this.defaultWorkflow);
				RuleUtil.setEmptyCalled = false;
            }

        }
    }
    this.isPendingFlag = false;
    RuleUtil.firstPass = 'N';
    resumeOnclickEvents();
}

function rules_msgBack(text) {
    alert(text);
}

function rules_isPending(){
    var undefined;
	var tmpIFrame = eval("window.hasIFrame");
	if(tmpIFrame != undefined) {
		return (this.isPendingFlag || IFrame.inUse);
	}
    return (this.isPendingFlag);
}

var RuleUtil = new Object();
RuleUtil.evaluateRules = rules_evaluateRules;
RuleUtil.triggerCreateEvent = rules_triggerCreateEvent;
RuleUtil.defaultWorkflow = null;
RuleUtil.setDefaultWorkflow = rules_setDefaultWorkflow;
RuleUtil.setFormName = rules_setFormName;
RuleUtil.setReloadFlag = rules_setReloadFlag;
RuleUtil.setChangeRequestTypeFlag = rules_setChangeRequestTypeFlag;
RuleUtil.setCopyRequestFlag = rules_setCopyRequestFlag;
RuleUtil.creationRuleArray = new Array();
RuleUtil.applyRules = rules_applyRules;
RuleUtil.setField = rules_setField;
RuleUtil.callBack = rules_callBack;
RuleUtil.msgBack = rules_msgBack;
RuleUtil.isPendingFlag = false;
RuleUtil.isPending = rules_isPending;
RuleUtil.changeRequestTypeFlag = false;
RuleUtil.copyRequestFlag = false;
RuleUtil.RULE_MODE_REQUEST = 0;
RuleUtil.RULE_MODE_TABLE_COMP = 1;
RuleUtil.RULE_MODE_REPORT = 2;
RuleUtil.firstPass = 'Y';
RuleUtil.mode = RuleUtil.RULE_MODE_REQUEST;
RuleUtil.setEmptyCalled = false;
RuleUtil.setRequired = rules_setRequired;
RuleUtil.setDisplayOnly = rules_setDisplayOnly;
RuleUtil.setValueFromToken = rules_setValueFromToken;
RuleUtil.setClear = rules_setClear;

/**
 ** The JSRule object
 **/

function jsrule_addDependantField(dep) {
    if(this.event == ON_CREATION) {
        RuleUtil.creationRuleArray[this.sequence] = this;
    } else {
        if(!dep.element) {
          this.hasAllDependents = false;
          return;
        }
        if(dep.element.addListener) {
            dep.element.addListener(this);
        }
        // Do not set as dependency if this is not a creation event.
        this.DepArray.push(dep);
    }
}

function jsrule_isValid() {
    if(this.hasAllDependents) {
        var len = this.DepArray.length;
        for (var i = 0; i < len; i++) {
            if(!this.DepArray[i].isValid()) {
                return false;
            }
        }
        return true;
    }
    return false;
}

function jsrule_getDepValue() {
    return this.dependentValue;
}

function jsrule_setDepValue(newDepValue) {
    this.dependentValue = newDepValue;
}

function jsrule_getTravTokens() {
    return this.traversedTokens;
}

function jsrule_setTravTokens(newTravTokens) {
    this.traversedTokens = newTravTokens;
}

function jsrule_setCodeString(yesno) {
    this.isCS = yesno;
}

function jsrule_isCodeString() {
    return this.isCS;
}

function JSRule(seq, name, event, tokens, ruleType) {
    this.sequence = seq;
    this.name = name;
    this.event = event;
    this.hasAllDependents = true;
    this.ruleType = ruleType;
    this.dependentValue = '';
    this.traversedTokens = '';
    this.isCS = '';
    if(this.event == ON_CREATION) {
        RuleUtil.creationRuleArray[this.sequence] = this;
    }
    this.tokens = tokens;
    this.DepArray = new Array();

    if(!hashParentChildPageTokens &&
       RuleUtil.formName!=undef &&
       RuleUtil.formName!="" &&
       RuleUtil.formName.indexOf(TABLECOMPFORM_PREFIX)!=-1)
    {
        if(tokens.indexOf("[REQ")){
            //if a token in the table component starts with "[REQ"
            hashParentChildPageTokens = true;
        }
    }
}
new JSRule(1, '', '', '', '');
JSRule.prototype.addDependantField = jsrule_addDependantField;
JSRule.prototype.isValid= jsrule_isValid;
JSRule.prototype.getDependentValue = jsrule_getDepValue;
JSRule.prototype.setDependentValue = jsrule_setDepValue;
JSRule.prototype.setCodeString = jsrule_setCodeString;
JSRule.prototype.isCodeString = jsrule_isCodeString;
JSRule.prototype.getTraversedTokens = jsrule_getTravTokens;
JSRule.prototype.setTraversedTokens = jsrule_setTravTokens;

/**
 ** DependantField Object
 **/

/**
 * Check that the field has the value(s) provided, or has any
 * value if the matchall flag is set.
 */
function dep_isValid() {
    if(this.matchall) {
        return true;
    } else {
        // Ask the element if it matches the value.
        return this.element.chkValue(this.values, this.isCodeString);
    }
}

/**
 * token:        The token of the field
 * valueArray:   An array of values the field can have. For the dependency to be
 *               true, the field must match all of the values.
 * matchall:     overrides the valueArray parameter. If matchall is true then any
 *               selected value makes the dependency true.
 * isCodeString: True if the value(s) in valueArray are codeStrings or not.
 */
function DependantField(token, valueArray, matchall, isCodeString) {
    if(token.length == 0) return; // So we can use the prototype logic below without
                                  // actually setting up a dependency
    this.element = getTokenElement(token, RuleUtil.formName);
    this.values = valueArray;
    this.matchall = matchall;
    this.isCodeString = isCodeString;
}
new DependantField('', [], false);
DependantField.prototype.isValid = dep_isValid;

function gotoUrlRefs(url)
{
  if(url.length == 0) {
    return;
  }
  //Bug:80583 escaped the Filename so that the
  //File could have special characters.
  //Seems to be a problem only with I.E
  //This assumes that the FILE_NAME is the last parameter in the URL.
  //This is a workaround for I.E as I.E re-encodes the FILE_NAME back
  //When the File is opened in a new browser window.
  //We do encode the FILE_NAME in JAVA.
  if( (navigator.appName.indexOf("Netscape") == -1) && (url.indexOf('&FILE_NAME=') != -1) ){
      var pattern = /&FILE_NAME=/i;
      var str_array = url.split(pattern);
      url = str_array[0]+'&FILE_NAME='+cl_escape(str_array[1]);
  }

  if(url.indexOf('://') == -1 && url.indexOf('testdirector:') == -1) {
    url = 'http://' + url;
  }
  var windoidName = null;
  if(url.indexOf('REQUEST_ID') != -1){
      windoidName = getUniqueRefWinName(url,'REQUEST_ID');
  }else if(url.indexOf('PACKAGE_ID') != -1){
      windoidName = getUniqueRefWinName(url,'PACKAGE_ID');
  }else if(url.indexOf('TASK_ID') != -1){
      windoidName = getUniqueRefWinName(url,'TASK_ID');
  }else if(url.indexOf('PROJECT_ID') != -1){
      windoidName = getUniqueRefWinName(url,'PROJECT_ID');
  }
  //Request#146829
  if (url.indexOf('REQUEST_ID') != -1 ||
      url.indexOf('PACKAGE_ID') != -1 ||
      url.indexOf('PROGRAM_ID') != -1 ||
      url.indexOf('TASK_ID') != -1 ) {
    openWindoid(url,null,null,"toolbar=no,location=no,directories=no,status=yes,menubar=yes,scrollbars=yes,resizable=yes,copyhistory=no,height=screen.availHeight,width=screen.availWidth",windoidName);
  } else if (base_url == undef || base_url == null || url.indexOf(base_url) != -1) {
    //Request#123269
    openWindoid(url,null,null,"toolbar=no,location=no,directories=no,status=yes,menubar=yes,scrollbars=yes,resizable=yes,copyhistory=no,height=550,width=800",windoidName);
  } else {
    popupExternalUrlWindow(url, null);
  }
}

//
// Base on the URL, extract the unique name to open a windoid for reference
//
function getUniqueRefWinName(url, pkid){
   var windoidName = null;
   var tempArray = url.split("=");
   for(var i = 0; i < tempArray.length; i++){
      if(tempArray[i].indexOf(pkid) != -1){
          if(tempArray.length > i + 1){
              windoidName = pkid + tempArray[i+1];
          break;
      }
      }
   }
   return windoidName;

}

function gotoAboutKintana(url)
{
  window.open(url, 'AboutKintana', 'resizable=no,width=600,height=400');
}

function gotoAccessInfo(url)
{
    window.open(url, 'AccessInfo', 'resizable=no,width=600,height=285');
}

/**
 * TimeZones of the world
 */
 var TimeZones = [ ['adt', -3  * 3600 * 1000 ],    // Atlantic Daylight
                 ['edt',   -4  * 3600 * 1000 ],    // Eastern Daylight
                 ['cdt',   -5  * 3600 * 1000 ],    // Central Daylight
                 ['mdt',   -6  * 3600 * 1000 ],    // Mountain Daylight
                 ['pdt',   -7  * 3600 * 1000 ],    // Pacific Daylight
                 ['ydt',   -8  * 3600 * 1000 ],    // Yukon Daylight
                 ['hdt',   -9  * 3600 * 1000 ],    // Hawaii Daylight
                 ['bst',   +1  * 3600 * 1000 ],    // British Summer
                 ['mest',  +2  * 3600 * 1000 ],    // Middle European Summer
                 ['sst',   +2  * 3600 * 1000 ],    // Swedish Summer
                 ['fst',   +2  * 3600 * 1000 ],    // French Summer
                 ['wadt',  +8  * 3600 * 1000 ],    // West Australian Daylight
                 ['eadt',  +11 * 3600 * 1000 ],    // Eastern Australian Daylight
                 ['nzdt',  +13 * 3600 * 1000 ],    // New Zealand Daylight
                 ['gmt',    0                ],    // Greenwich Mean
                 ['ut',     0                ],    // Universal (Coordinated)
                 ['utc',    0                ],
                 ['wet',    0                ],    // Western European
                 ['wat',   -1  * 3600 * 1000 ],    // West Africa
                 ['at',    -2  * 3600 * 1000 ],    // Azores
                 ['ast',   -4  * 3600 * 1000 ],    // Atlantic Standard
                 ['est',   -5  * 3600 * 1000 ],    // Eastern Standard
                 ['cst',   -6  * 3600 * 1000 ],    // Central Standard
                 ['mst',   -7  * 3600 * 1000 ],    // Mountain Standard
                 ['pst',   -8  * 3600 * 1000 ],    // Pacific Standard
                 ['yst',   -9  * 3600 * 1000 ],    // Yukon Standard
                 ['hst',   -10 * 3600 * 1000 ],    // Hawaii Standard
                 ['cat',   -10 * 3600 * 1000 ],    // Central Alaska
                 ['ahst',  -10 * 3600 * 1000 ],    // Alaska-Hawaii Standard
                 ['nt',    -11 * 3600 * 1000 ],    // Nome
                 ['cet',   +1  * 3600 * 1000 ],    // Central European
                 ['met',   +1  * 3600 * 1000 ],    // Middle European
                 ['mewt',  +1  * 3600 * 1000 ],    // Middle European Winter
                 ['swt',   +1  * 3600 * 1000 ],    // Swedish Winter
                 ['fwt',   +1  * 3600 * 1000 ],    // French Winter
                 ['eet',   +2  * 3600 * 1000 ],    // Eastern Europe USSR Zone 1
                 ['bt',    +3  * 3600 * 1000 ],    // Baghdad USSR Zone 2
                 ['zp4',   +4  * 3600 * 1000 ],    // USSR Zone 3
                 ['zp5',   +5  * 3600 * 1000 ],    // USSR Zone 4
                 ['zp6',   +6  * 3600 * 1000 ],    // USSR Zone 5
                 ['wast',  +7  * 3600 * 1000 ],    // West Australian Standard
                 ['cct',   +8  * 3600 * 1000 ],    // China Coast USSR Zone 7
                 ['jst',   +9  * 3600 * 1000 ],    // Japan Standard USSR Zone 8
                 ['east',  +10 * 3600 * 1000 ],    // Eastern Australian Standard
                 ['gst',   +10 * 3600 * 1000 ],    // Guam Standard USSR Zone 9
                 ['nzt',   +12 * 3600 * 1000 ],    // New Zealand
                 ['nzst',  +12 * 3600 * 1000 ]     // New Zealand Standard
];

var timeZone;

function buildTimeZoneRE() {
    var tzRE = "(gmt(\\+|-)((\\d){1,2}[:]?(\\d){1,2})|";
    for(var i = 0; i < TimeZones.length; i++) {
        tzRE += TimeZones[i][0];
        if(i < TimeZones.length - 1) {
            tzRE += "|";
        }
    }
    tzRE += "|" + tzString;
    tzRE += ")?";
   return tzRE;
}

// Allows subtemplates to disable this function.
var enableFocusSniffer = false;

// Function to find a focusable form element.
function setInitialFocus() {
  var foundElement = false;
  if ( enableFocusSniffer == true && document.forms != null ) {
    for ( i=0 ; i<document.forms.length ; i++ ) {
      if ( document.forms[i].elements != null ) {
        currElements = document.forms[i].elements;
        for ( j=0 ; j<currElements.length ; j++ ) {
            if ( currElements[j].focus != null && currElements[j].type != null &&
                 currElements[j].type != 'hidden' && !currElements[j].disabled ) {
                try {
                    currElements[j].focus();
                    foundElement = true;
                    break;
                } catch (e) {
                    // find the next focusable element
                }
            }
        }
      }
      if ( foundElement ) break;
    }
  }
}


/**
 *  BEGIN LISTBOX OBJECT
 */

function lb_removeAt(index) {
    for (var i = index; i < this.refArray.length - 1; i++) {
        this.refArray[i] = this.refArray[i+1];
    }
    this.options[index] = null;
    this.refArray.length--;
}

function lb_getLength() {
  return this.refArray.length;
}

function lb_getValueAt(index) {
  return this.refArray[index];
}

function lb_addValue(ref) {
  // we need to clone the object because if we push the reference passed in,
  // the reference object will get garbage collected when the child window closes
  this.refArray.push(new Reference(ref.referenceType, ref.targetTypeCode, ref.targetId, ref.referenceName, ref.refRelationshipId, ref.refBehaviorCode, ref.relationshipName, ref.description, ref.link, ref.storedFilename));
}

/**
 * Clears all Reference values from the list box
 */
function lb_clearValues() {
    for (var i = this.refArray.length - 1; i >= 0; i--) {
        this.removeAt(i);
    }
}

/**
 *  ListBox javascript object definition.
 */
function ListBox(label, element, form) {
    this.clLabel = label;
    this.name = element.name;
    this.options = element.options;
    this.element = element;

    this.refArray = new Array();
}
new ListBox("", "", "");
ListBox.prototype.addValue = lb_addValue;
ListBox.prototype.removeAt = lb_removeAt;
ListBox.prototype.getLength = lb_getLength;
ListBox.prototype.getValueAt = lb_getValueAt;
ListBox.prototype.clearValues = lb_clearValues;

function Reference(referenceType, targetTypeCode, targetId, referenceName, refRelationshipId, refBehaviorCode, relationshipName, description, link, storedFilename) {
    this.referenceType = referenceType; // eg. Request, Package
    this.targetTypeCode = targetTypeCode; // eg. 20, 1 (target_type_code)
    this.targetId = targetId; // eg. 12345 (a string value)
    this.referenceName = referenceName; // eg. 12345 (a string value)
    this.refRelationshipId = refRelationshipId; // Note: this should be passed as a string
    this.refBehaviorCode = refBehaviorCode;
    this.relationshipName = relationshipName;
    this.description = description; // for URLs, attachments
    this.link = link; // the URL that is opened when a user presses the Open button with this reference selected
    this.storedFilename = storedFilename; // for attachments
    if (this.storedFilename == null) {
        this.storedFilename = "";
    }
}
new Reference("", "", "", "", "");
Reference.prototype.getDisplayText = ref_getDisplayText;
Reference.prototype.getLink = ref_getLink;

/**
 * returns the URL that is opened when the user clicks the Open button with this reference selected
 */
function ref_getLink() {
    return this.link;
}

/**
 * Returns the text to be displayed to the user in the list box
 */
function ref_getDisplayText() {
    if (this.relationshipName == "") {
        if (this.targetTypeCode == "55") { // attachment
            return formatMessage(addedReferenceNoRelNameMessage, '', this.referenceName);
        } else {
            return formatMessage(addedReferenceNoRelNameMessage, this.referenceType, this.referenceName);
        }
    }
    return formatMessage(addedReferenceMessage, this.referenceType, this.referenceName, this.relationshipName);
}

var origOnclick = window.onclick;
function event_eatclick(event){
    return false;
}

function suspendOnclickEvents(){
    if(window.captureEvents){
        window.captureEvents(Event.CLICK);
        window.onclick = event_eatclick;
    }
}
function resumeOnclickEvents(){
    if(window.releaseEvents){
        window.releaseEvents(Event.CLICK);
        window.onclick = origOnclick;
    }
}

function popupWindow(url, name) {
    var w = 800;
    var h = 550;
    var winl = (screen.width - w) / 2;
    var wint = (screen.height - h) / 2;
    winprops = 'height='+h+',width='+w+',top='+wint+',left='+winl+',scrollbars=yes,resizable';
    win = null;
    win = window.open(url, name, winprops);
    if (parseInt(navigator.appVersion) >= 4 && window.focus) {
        win.focus();
    }
}

/**
 * wng
 *
 */
function selectAttachmentFile(attachmentLabel, browseComp, attachButton, deleteButton) {
    var linkText = "";
    var meaningText = "";

    if (browseComp.value != null && browseComp.value != "" && browseComp.value != "&nbsp") {

        if (browseComp.value.length > 35) {
            meaningText = browseComp.value.substring(0, 34) + "...";
            attachmentLabel.onMouseover='javascript:showHoverText(browseComp.value,10,10,attachButton); return true';
        } else {
            attachmentLabel.onMouseover='javascript:hideHoverText()';
            meaningText = browseComp.value;
        }

        //linkText = "<a href='" + browseComp.value + "'>";
        // target='WINDOID_" + attachmentLabel.value + "' onclick='openWindoidWithMenu(\"" + attachmentLabel.value + "\");
        //attachmentLabel.innerHTML = linkText + meaningText + "</a>\n";

        attachmentLabel.innerHTML = meaningText;
        attachmentLabel.value=meaningText;

        deleteButton.style.display='inline';
        attachButton.title='Replace';
    } else {
        deleteButton.style.display='none';
        attachButton.title='Choose';
        attachmentLabel.onMouseover='javascript:hideHoverText()';
    }
}

function removeAttachmentFile(attachmentLabel, attachButton, deleteButton) {
    attachmentLabel.innerHTML = "(no&nbsp;document&nbsp;attached)";
    attachmentLabel.value = "";
    deleteButton.style.display='none';
    attachButton.title='Choose';
}

function showAttachmentHover(attachmentLabel, attachButton, truncationLength) {
    if (attachmentLabel.value.length > truncationLength) {
        //showHoverText('Thisisatest', 10, 10, attachButton);
        //showHoverText(attachmentLabel.value, 10, 10, attachButton);
        return true;
    }

    return true;
}


/**
 * Pops up a window that is mean for an external URL.  External URL means the URL doesn't have the same
 * base URL as the rest of the side.  The specialness of this popup (difference with popupWindow), is that
 * standard menu bars are enabled.
 *
 * @author	William Wang
 * @param	url URL to open
 * @param	name Name for the new popup window
 */
function popupExternalUrlWindow(url, name) {
    var w = 800;
    var h = 550;
    var winl = (screen.width - w) / 2;
    var wint = (screen.height - h) / 2;
    win = null;
    try {
        //REQEST#123269
        win = window.open(url, name,"width=800,height=550,toolbar=no,location=no,directories=no,status=yes,menubar=yes,scrollbars=yes,resizable=yes,copyhistory=no");
    } catch(e) {
        var errmsg = e.name + "\n" + e.message;
        //alert(formatMessage(reqMessage,deEscapeFromHTML(url)));
        alert(formatMessage(errorOpeningURL, deEscapeFromHTML(url), e.name, e.description, e.message));
        //alert(errmsg);
    }
    if (parseInt(navigator.appVersion) >= 4 && window.focus) {
        win.focus();
    }
}

function closeWindow () {
    window.close();
}

/**
 * Shows the hover text for auto-completes
 */
function showAutoCompleteHoverText(token) {
  var content = document.getElementById(token + AC_TEXTFIELD_ID_SUFFIX).value;

  // if content is empty, then do not show the popup
  if (content == "" || content.indexOf("; ") == -1)
    return;

  // escape values for HTML
  var newContent = escapeForHTML(content);

  // replace the delimiter
  newContent = newContent.replace(/;\s/g, "<br>\n");

  showHoverText(newContent, 25, 15, token + HOVER_LOCATOR_SUFFIX);
}

/**
 * Shows the hover text for auto-completes
 */
function showChooserHoverText(token, id) {

  var content = document.getElementById(id).value;

  // if content is empty, then do not show the popup
  if (content == "")
    return;

  // escape values for HTML
  var newContent = escapeForHTML(content);

  // replace the delimiter
  newContent = newContent.replace(/;\s/g, "<br>\n");

  showHoverText(newContent, 25, 15, token + HOVER_LOCATOR_SUFFIX);
}


/**
 * Extends from TextField so it can reuse field dependency rule
 */
function FileDirChooserPopup(label, element, valueElement, required, emptyString, tokenName,  visibleTokenName, dataMaskObject, form, onValueChange, isBlankable, isMulti, validationID, chooserType, imageTag) {
	this.base = TextField;
	this.base(label, element, valueElement, required, emptyString, tokenName,  visibleTokenName, dataMaskObject, form, onValueChange, isBlankable, validationID);
	this.chooserType = chooserType;
	this.isMulti = isMulti;
	this.validationID = validationID;
	this.formName = form;
    this.disabledClass = this.element.className;
    this.imageTag = imageTag;
    this.setTextFieldValue = dataMaskObject.tfSetValue;
    this.setValue = chooser_setValue;
    this.validate = chooser_validate;
}

new FileDirChooserPopup("","","","","","","",false,"","", false,false,"","","");
FileDirChooserPopup.prototype.addListener = rules_addListener;
FileDirChooserPopup.prototype.getTokenValue = textField_getTokenValue;
FileDirChooserPopup.prototype.getLabel = getLabel;
FileDirChooserPopup.prototype.setEnabled = chooser_setEnabled;
FileDirChooserPopup.prototype.setRequired = generic_setRequired;
FileDirChooserPopup.prototype.chkValue = textfield_chkValue;
FileDirChooserPopup.prototype.getValue = textfield_getValue;
FileDirChooserPopup.prototype.getValueForRule = textfield_getValueForRule;
FileDirChooserPopup.prototype.isCodeString = no_codestring;
FileDirChooserPopup.prototype.onClick = chooser_onClick;
FileDirChooserPopup.prototype.setValue = chooser_setValue;
FileDirChooserPopup.prototype.getWorkflowID = getWorkflowID;
FileDirChooserPopup.prototype.getPSubPath = getPSubPath;
FileDirChooserPopup.prototype.getElementValueByMatchID = getElementValueByMatchID;
FileDirChooserPopup.prototype.getPFileLocation = getPFileLocation;
FileDirChooserPopup.prototype.getValueByToken = getValueByToken;
FileDirChooserPopup.prototype.setFDChooserValue = chooser_setFDChooserValue;

function chooser_validate(forceCheck) {
	if (this.isEnabled == false) {
        // the component is not enabled, there's no need for validation, just return true
        return true;
    }
    var fieldValue;
    if (this.element.type == 'hidden') {
        fieldValue = FDdecode(this.valueElement.value, true, this.isMulti);
    } else {
        fieldValue = trimString(this.element.value);
    }

    // error if required and trimmed value matches empty value
    if(checkRequired && (this.required || (forceCheck != null && forceCheck)) &&
       (fieldValue==this.emptyString || fieldValue=="")) {
        requiredAlert(this.clLabel);
        return false;
    }
    if(!this.isMulti) {
	    // if the field is not validated, and the field does have some value, validate it
	    if(fieldValue != null && fieldValue.length != 0){
	        var code;
	        code = this.dataMaskObject.parseValue(fieldValue, this.clLabel);
	        if(!this.dataMaskObject.isValid(code)){
	            return false;
	        }
	        var meaning = this.dataMaskObject.fmtValue(code);
	        // handle blankable text fields
	        if (this.isBlankable && meaning.toUpperCase() == BLANK_FIELD_TEXT.toUpperCase()) {
	          code = BLANK_VALUE_CODE_STRING;
	        }

	        this.dataMaskObject.setValueElement(this.valueElement, code, meaning);
	        this.element.value = meaning;
	    }
	    this.dataMaskObject.toggleColor(this.divObj!=null?this.divObj:this.element, code);
    } else {
    	if(fieldValue != null && fieldValue.length != 0){
	    	var value = FDMultiEncode(fieldValue);
	    	var segments = null;

	    	var temp = fieldValue.substring(1, fieldValue.length - 1);
	    	segments = temp.split(MULTICHOOSER_DELIMITER);
	    	for(var i=0; i < segments.length; i++) {
		    	if(!this.dataMaskObject.isValid(segments[i])){
		            return false;
		        }
	    	}

		    this.valueElement.value = value;
		    this.element.value = fieldValue;
	    }
    }
    return true;
}

function chooser_setValue(codeString, noCascade) {
	checkRequired = false;
	if(!this.isMulti) {
		this.setTextFieldValue(codeString, noCascade);
	} else {
		if(codeString != null){
			var value = FDdecode(codeString, true, true);
			this.element.value = trimString(value);
			if(value == null || value == "" || value == "\"\"") {
				this.valueElement.value = "0.0..";
			} else {
				this.valueElement.value = codeString;
			}
			if( noCascade == undef || noCascade ) {
	            this.element.cachedValue = this.element.value;
	        }
	        if(value != null) {
	         	this.isValidated = false;
		        return this.validate(false);
	        }
        }
	}
	checkRequired = true;
}

/**
 *  Set the isEnabled flag to false and the autocomplete image would grey out
 */
 function chooser_setEnabled(flag){
    if(flag) {
        this.isEnabled = true;
        // set the field's disabled property to be false in IE & Netscape7
        this.element.disabled = false;
        this.element.className = this.defaultClass;
        var icon = document.getElementById(this.element.id + this.imageTag);
        if(icon) {
        	if(this.chooserType == "directory") {
        		icon.src = "../global/images/DirChooser.gif";
        	} else {
        		icon.src = "../global/images/FileChooser.gif";
        	}
        }
        // set the focus to that field
        //this.element.focus();
    } else {
        this.isEnabled = false;
        // in IE, just set the disabled property to be true, and change the style class to grey
        this.element.disabled = true;
        this.element.className = this.disabledClass;
        var icon = document.getElementById(this.element.id + this.imageTag);
        if(icon) {
        	if(this.chooserType == "directory") {
        		icon.src = "../global/images/DirChooser_off.gif";
        	} else {
        		icon.src = "../global/images/FileChooser_off.gif";
        	}
        }
    }
 }

/**
 * The function try to find the the value of element by matching the id using
 * the regular expression reFirst and  regular expression reSecond(optional)
 */
function getElementValueByMatchID(reFirst, reSecond, meaning) {

var form = document.forms[this.formName];
	if(form) {
	    var elements = form.elements;
	    if (elements) {
	    	for(i = 0; i < elements.length; i++) {
	    		if(elements[i].id) {

		    		if(elements[i].id.search(reFirst) != -1) {

		    			if(reSecond) {
		    			   	if (elements[i].id.search(reSecond) != -1) {
				    			if(elements[i].value) {
				    				return decodeCodeString(elements[i].value, meaning);
				    			}
				    		}
		    			} else if(elements[i].value) {
		    				return decodeCodeString(elements[i].value, meaning);
		    			}
		    		}
	    		}
	    	}
	    }
	    else {
	        return "";
	    }
    }
    return "";
}

/**
 * Get the html element value by matching element id with
 * the token
 *
 */
function getValueByToken(token) {
	if(!token || token == "") {
		return "";
	}
    var reg = new RegExp("^(P.)?"+token+"$","g");
    var regHV;
    //try to get from the editable parameter component first
    var value = this.getElementValueByMatchID(reg, regHV, false);
    //try to get the value from paramter hidden field
    if(!value || value == "") {
    	reg = new RegExp("^(P.)?"+token,"g");
    	regHV = new RegExp("HV$","g");
    	value = this.getElementValueByMatchID(reg, regHV, false);
    }
    //try to get the value from userdata hidden field
    if(!value || value == "") {
    	reg = new RegExp("^[A-Z]+.UD."+token,"g");
    	regHV = new RegExp("HV$","g");
    	value = this.getElementValueByMatchID(reg, regHV, false);
    }
    return value;
}

/**
 * Currently File/Dir chooser component only supports dynamic environment
 * through package workflow. Any support future workflow such as request
 * must modify ChooserJSPRenderer.java to change value for tokenPkgWorkflowID.
 */
function getWorkflowID(tokenPkgWorkflowID) {
	var reg = new RegExp("^"+tokenPkgWorkflowID,"g");
	var regHV = new RegExp("HV$","g");
	return this.getElementValueByMatchID(reg, regHV, false);
}

function getPSubPath(tokenSubPath) {
    return this.getValueByToken(tokenSubPath);
}

function getPFileLocation(tokenFileLocation) {
    return this.getValueByToken(tokenFileLocation);
}

/**
 * Return true if value is a token
 *
 */
function isToken(value) {
	var reg = /^\[[A-Z0-9._]+\]$/;
	if(value && value != "") {
		return reg.test(value);
	}
	return false;
}

function getTokenWithoutBracket(token) {
	var l = token.length;
	return token.substr(1,l - 2);
}

function getCSCompleteFiles(element, elementValue) {
	var delimiterIndex = element.value.lastIndexOf("\",\"");
	if(delimiterIndex != -1) {
		var lastFile = element.value.substring(delimiterIndex + 3,element.value.length - 1);
		var cutoffCSIndex = elementValue.value.indexOf(lastFile,0);
		if(cutoffCSIndex != -1) {
			var newCSValue = elementValue.value.substring(0,cutoffCSIndex + lastFile.length);
		} else {
			alert("Invalid CodeString value:"+elementValue.value);
		}
		return newCSValue;
	} else {
		alert("Invalid element value:"+element.value);
	}
	return "";
}

/**
 * Alert() function on Netscape does not wrap the long message.
 * This function will insert the newline in the long message
 */
function formatLongAlertMessage(str) {
	var delimiter = ",";
	var arrayStr = str.split(delimiter);
	var newStr = "";
	var firstIdx = 0;
	var secIdx = 0;
	var oldSecIdx = 0;
	var cutOffLength = 90;
	for (var i=0; i < arrayStr.length - 1; i++) {
	  oldSecIdx = secIdx;
	  secIdx = newStr.length + arrayStr[i].length;
	  if(secIdx - firstIdx > cutOffLength) {
	  	 newStr = newStr + "\n";
	  	 firstIdx = oldSecIdx;
	  }

      newStr = newStr + arrayStr[i] + ",";
   	}
	newStr = newStr + arrayStr[arrayStr.length - 1];

	return newStr;
}
/**
 *  sets the value of the autocomplete object with newCSValue.
 */
function chooser_setFDChooserValue(newCSValue, baseFileName, subPath, IsMulti){
   if (baseFileName!=null && baseFileName){
      visibleValue = FDdecode(newCSValue, false, IsMulti);
      }
   else{
      visibleValue = FDdecode(newCSValue, true, IsMulti);
    }

    this.valueElement.value = newCSValue;

	if(visibleValue == '..'){
	   subPath = subPath.substring(0, subPath.length-1);
	   subPath = subPath.substring(0, subPath.lastIndexOf('/')+1);
	   visibleValue = '';
	}
	 finalValue = subPath + visibleValue;

	if (finalValue.length>200){
	   var cutoffLength = 198;
	   var delimiter = "\",\"";
	   //trim the select values to completed files
	   var cutoffDelimiterIndex = finalValue.lastIndexOf(delimiter, cutoffLength + 3);

	       this.element.value = finalValue.substring(0, cutoffDelimiterIndex + 1); // +1 to include "
	   this.valueElement.value = getCSCompleteFiles(this.element, this.valueElement);
	   return "The value exceeds 200 characters and will be truncated to "+ formatLongAlertMessage(finalValue.substring(0,cutoffDelimiterIndex + 1)+".");
	}
	else{
	   if (IsMulti && finalValue == "")
	       finalValue = "\"\"";
	   this.element.value = finalValue;
	   return  "";
	}

      return "";
}



/**
 * Gathering required parameters such as cultext, validationID, workflowID, sub path, file location,
 * server path, client path and pass them to ChooserPopup.
 */
function chooser_onClick(tokenPkgWorkflowID, tokenSubPath, tokenFileLocation, serverPath, clientPath, environment) {
	if (this.isEnabled) {
        var currentSelectString = "";
        var loadingMessage = "";
        var objectName = this.name + ChooserPopupNamePostFix;
        var workflowID = "";
        var form = document.forms[this.formName];
        var pSubPath = "";
        var pFileLocation = this.getPFileLocation(tokenFileLocation);
        var pServerPath = serverPath;
        var pClientPath = clientPath;
        var pEnvironment = environment;
        //Request#142934:P_SUB_PATH is only used with file component.
        if(this.chooserType == "file") {
        	pSubPath = this.getPSubPath(tokenSubPath);
        }
        //get workflowID if this is Package Detail page.
        if (form.PACKAGE_ID_CONTEXT) {
            workflowID = this.getWorkflowID(tokenPkgWorkflowID);
        }

        if(isToken(serverPath)) {
        	pServerPath = this.getValueByToken(getTokenWithoutBracket(pServerPath));

        }

        if(isToken(pClientPath)) {
        	pClientPath = this.getValueByToken(getTokenWithoutBracket(pClientPath));

        }

        if(isToken(pEnvironment)) {
        	pEnvironment = this.getValueByToken(getTokenWithoutBracket(pEnvironment));

        }



       // check to see if chooser popup window is open
       // if it is, reset it and close out the previous auto-complete
       if (popup != null && popup != undefined && !popup.closed) {
       	 // popup window is open
       	 // now to check if it is an auto-complete window
       	 if (popup.window.closeWindoid != null && popup.window.closeWindoid != undefined) {
      	  	 if (popup.window.name == objectName) {
      	  	   // same field, do not clear out cull text
           	 popup.window.closeWindoid(true);
      	  	 } else {
      	  	 	 // different field, clear out cull text
      	  	 	 popup.window.closeWindoid();
      	  	 }
       	 }
       }


       // if we have a defined event, the user clicked the icon, grab the location of the event for the
       // popup location calculation.
       if(window.event) {
         this.tabeventx = window.event.screenX;
         this.tabeventy = window.event.screenY;
       } else {
         if(!this.tabeventx) {
           this.tabeventx = 100;
           this.tabeventy = 100;
         }
       }
       document[objectName] = this;
       // calculate where on the screen the window should go
       var popupLocation = calculatePopupLocation(chooserPopupWidth,chooserPopupHeight, this.tabeventx, this.tabeventy);
       popup = window.open(BLANK_PAGE,
                            objectName,
                            popupLocation+",toolbar=no,location=no,directories=no,status=no,menubar=no,scrollbars=no,resizable=yes,copyhistory=no,width=" + chooserPopupWidth + ",height=" + chooserPopupHeight);
       // we need to manually set the cookie in the popup window because IE4 doesn't send it
        var allcookies = document.cookie;
        var pos = allcookies.indexOf("JSESSIONID=");

	var temp;
        if (this.chooserType == "directory")
	   temp = 2;
	else
	   temp = 1;


        // we need to decide whether it is a multi-select or single-select chooser
        var isMultiString = "N";
        if(this.isMulti)
            isMultiString = "Y";
        // now we can forward to the AutoCompPopupHandler


         newValueElement = this.valueElement.value;
	 if (newValueElement.indexOf("#@#")==-1){ // not a mutlti value CS
  	      newValueElement = decode(newValueElement, true);
 	      if (newValueElement.indexOf(",")!= -1){ // it is not a true CS
	        while (newValueElement.indexOf('"')!= -1){
	          newValueElement = newValueElement.replace('"','');
	        }	 // replace all '' to empty
	 	 while (newValueElement.indexOf(', ')!= -1){
	            newValueElement = newValueElement.replace(', ','#@#');
         	 }
	 	 while (newValueElement.indexOf(',')!= -1){
	            newValueElement = newValueElement.replace(',','#@#');
         	 }
		 newValueElement = encode(newValueElement, newValueElement);
	      } else{
	        while (newValueElement.indexOf('"')!= -1){
	          newValueElement = newValueElement.replace('"','');
	        }	 // replace all '' to empty
 	         newValueElement = encode(newValueElement, newValueElement);
	      }
	 }

	newCullText = this.element.value;
	while(newCullText.indexOf('"')!=-1){
	   newCullText = newCullText.replace('"','');
	}
	if (this.isMulti){

            if (newCullText.indexOf(',')==-1){ // single value
	        if (newCullText.indexOf('.') !=-1)
                    newCullText = newCullText.substring(0, newCullText.indexOf('.'));

	    }else{ // multi value
	        newCullText = '';
	    }
	}

              newLoc = getHostPath() +
                        fileFolderChooserPopupServlet +
                        "&CULL_TEXT=" + cl_escape(newCullText) +
                        "&CHOOSER_PROMPT=" + encodeURIComponent(this.clLabel) +
                        "&MULTI_FLAG=" + isMultiString +
                        "&VALIDATION_ID=" + escape(this.validationID) +
                        "&CHOOSER_TYPE=" + temp +
                        "&WORKFLOW_ID=" + escape(workflowID) +
                        "&P_SUB_PATH=" + escape(pSubPath) +
                        "&P_FILE_LOCATION=" + escape(pFileLocation)+
                        "&P_ENVIRONMENT=" + escape(pEnvironment) +
                        "&CURRENT_SELECTED_TEXT="+escape(newValueElement);
            if(serverPath != "") {
            	newLoc = newLoc + "&SERVER_BASE_PATH=" + escape(pServerPath);
			}
			if(clientPath != "") {
                newLoc = newLoc + "&CLIENT_BASE_PATH=" + escape(pClientPath);
            }
            // other browsers can reload the popup window themselves

            popup.document.writeln(globalStyleSheet);
            var callback = 'this.window.opener.document["' + objectName + '"].windowIsOpen = false';
            popup.document.writeln("<html><head><title>IT Governance "+this.chooserType+" chooser</title><SCRIPT>"+getPopupLocation(newLoc,this)+"</SCRIPT></head><body onUnload='"
                               + callback + "' style='background-color: #EFEFEF'><center><h1><font face=verdana>" + loadingMessage + "</font></h1></center></body></html>");
    }
    return;


}



/**
 *  BEGIN LINK OBJECT
 */
function _validateLink(forceCheck) {
    this.element.value = trimString(this.element.value);

    //error if required and trimmed value matches empty value
    if(checkRequired && (this.required || (forceCheck != null && forceCheck)) &&
       ((this.element.value==this.emptyString) || (this.element.value==''))) {
        requiredAlert(this.clLabel);

        return false;
    }
    return true;
}

function link_onchange() {
	if(this.RuleArray.length > 0) {
		RuleUtil.isPendingFlag = true;
		RuleUtil.evaluateRules(this.RuleArray, this.getValue(), this.isCodeString());
	} else {
		RuleUtil.isPendingFlag = false;
		resumeOnclickEvents();
	}
	this.isValidated = false;
}


function link_setValue(codeString, noCascade) {

    if( noCascade == undef || noCascade ) {
    	if (this.element.cachedValue == undef) {//only for the first time
			this.element.cachedValue = this.element.value;
		}
	}

    this.element.value = codeString;

	//update link
	var linkDesc = decode(codeString,true);
	var linkURL = decode(codeString,false);
	//if link description is empty display the url
	if (linkDesc == "") {
		linkDesc = linkURL;
	}

	//this is a hack until I add a JS method that wraps the text,
	//the method should replace the text_fmtValue method of this obejct
	if (linkDesc.length > this.size) {
		linkDesc = linkDesc.substring(0,this.size) + "..."
	}

	var urlLink = document.getElementById(this.tokenName + '_REF');
	if (linkDesc == "") {
		urlLink.removeAttribute("href");
		urlLink.innerHTML = "<span class='disabled-field-value'>(No Link)</span>";
	} else {
		linkURL = linkURL.replace(/\\/g, '\\\\');
		linkURL = linkURL.replace(/\'/g, '\\\'');
		urlLink.href = "javascript:gotoUrlRefs('" + linkURL + "');"
		urlLink.innerHTML = escapeForHTML(linkDesc);
	}
}


function link_reset(){
	if (this.element.cachedValue) {
    	this.setValue(this.element.cachedValue, false);
    }
}

/**
 *  Link javascript object definition.
 */
function Link(label, element, required, emptyString, tokenName,  visibleTokenName, form, size) {
    this.clLabel = label;
    this.name = element.name;
    this.element = element;
    this.required = required;
    this.size = size;
    this.emptyString = emptyString;
    this.RuleArray = new Array();

    if(tokenName != ""){
        new Token(tokenName, this, false, form);
    }
    if(visibleTokenName != ""){
        new Token(visibleTokenName, this, true, form);
    }
}

new Link("", "", false, "", "", "", "");
Link.prototype.addListener = rules_addListener;
Link.prototype.validate = _validateLink;
Link.prototype.getTokenValue = std_getTokenValue;
Link.prototype.setEnabled = textField_setEnabled;
Link.prototype.getLabel = getLabel;
Link.prototype.setValue = link_setValue;
Link.prototype.setRequired = generic_setRequired;
Link.prototype.getValue = textfield_getValue;
Link.prototype.getValueForRule = textfield_getValue;
Link.prototype.isCodeString = yes_codestring;
Link.prototype.text_fmtValue = textField_fmtValue;
Link.prototype.onchange = link_onchange;
Link.prototype.reset = link_reset;

/**
 *  END Link OBJECT
 */


